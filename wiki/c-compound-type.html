<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>复合数据类型 | HaHack</title>
  <meta name="author" content="Joseph Pan">
  
  <meta name="description" content="结构体
定义结构体
例如，如果用实部和虚部表示一个复数[1]，我们可以写成由两个double型组成的结构体：
123struct complex_struct{    double x, y;};
这一句定义了标识符complex_struct（同样遵循标识符的命名规则），这种标识符在C语言中称为T">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="复合数据类型"/>
  <meta property="og:site_name" content="HaHack"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/images/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="HaHack" type="application/atom+xml">
  
  <link rel="stylesheet" href="/dist/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/bootstrap-responsive.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/font-awesome.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/style.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/highlight.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/sidenav.min.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/dist/responsive.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/bubble.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/google-fonts.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/nprogress.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/comment.min.css" media="screen" type="text/css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <!--[if lte IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

<!--  -->
<!--     <link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow|PT+Sans:400,400italic,700,700italic|Droid+Serif:400,400italic' rel='stylesheet' type='text/css'> -->
<!--     <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'> -->
<!--  -->
  
<script src="/dist/jquery-2.0.3.min.js"></script>


    <script src="/dist/videoGFW.min.js"></script>
	
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-41569408-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;

ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';

var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

	


    <link rel="stylesheet" href="/dist/highlight-default.min.css" media="screen" type="text/css">
    
    <script src="/dist/comment.min.js"></script>
    <script src="/dist/marked.min.js"></script>
    
    <script src="/dist/highlight.min.js"></script>
    <script src="/dist/timeago.min.js"></script>
	<script src="/dist/spin.min.js"></script>


</head>


<body data-spy="scroll" data-target=".toc">  
  <header id="header" class="inner"><div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
            <a data-pjax class="brand" href="/">HaHack</a>
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <div class="nav-collapse collapse">
            <ul class="nav">				
			    
				   <li><a data-pjax href="/archive" title="所有文章归档"><i class="fa fa-archive"></i>Archive</a></li>				   			    			
				   <li><a data-pjax href="/categories" title="所有文章分类"><i class="fa fa-folder"></i>Categories</a></li>				   			    			
				   <li><a data-pjax href="/tags" title="所有文章标签"><i class="fa fa-tags"></i>Tags</a></li>				   			    			
				
				<li class="divider-vertical"></li>
			   	<li><a data-pjax href="/wiki" title="我的笔记库"><i class="fa fa-tasks"></i>wiki</a></li>				   
				
            </ul>			
			<ul class="nav navright">
				<li class="dropdown works">
				<a data-pjax href="#" title="作品集" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-th-large"></i>Works <b class="caret"></b></a>
                                <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/wukong-robot" title="wukong-robot 是一个简单、灵活、优雅的中文语音对话机器人。"><i class="fa fa-github"></i>wukong-robot</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://hahack.com/codes/dingdang-robot-intro/" title="叮当是一款可以工作在 Raspberry Pi 上的中文语音对话机器人/智能音箱项目。"><i class="fa fa-github"></i>dingdang-robot</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://www.hahack.com/codes/comment-js/" title="纯JS实现的静态站点评论系统，使用 Github/OSChina 作为 backend。"><i class="fa fa-github"></i>comment.js</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://hahack.com/codes/eulerian-video-magnification/" title="首个完整的 C++ 开源实现，能同时放大动作变化和颜色变化"><i class="fa fa-github"></i>QtEVM</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/hexo-series" title="为 Hexo 写的一系列主题/工具/插件"><i class="fa fa-github"></i>hexo-series</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/scnu/scnuthesis" title="符合华南师范大学硕士/博士学位论文格式要求的LaTeX模板。"><i class="fa fa-github"></i>SCNUThesis</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/slides" title="一些幻灯片作品"><i class="fa fa-github"></i>Slides</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://hahack.com/codes/fcevm/" title="硕士毕业论文"><i class="fa fa-github"></i>Dissertation</a></li>
				
                	        </ul>
				</li>
				<li class="dropdown">
				<a data-pjax href="#" title="订阅本站" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-rss"></i>Subscribe <b class="caret"></b></a>
                                <ul class="dropdown-menu" role="menu" aria-labelledby="drop2">
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="/atom.xml" title="使用 RSS 阅读器订阅 HaHack"><i class="fa fa-rss-square"></i>RSS</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="/wechat.html" title="订阅 HaHack 的公众平台"><i class="fa fa-qrcode"></i>WeChat</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="http://toutiao.io/u/147640" title=""><i class="fa fa-align-justify"></i>Toutiao</a></li>
				
                	        </ul>
				</li>
				
				<li><a data-pjax href="/about" title="关于我"><i class="fa fa-user"></i>About</a></li>				   				
   					  
            </ul>
            </div> <!-- nav-collapse collapse -->
        </div> <!-- container -->
     </div> <!-- navbar-inner -->
</div> <!-- navbar navbar-inverse -->
</header>
  <div class="container" id="container">
  	<div class="content">
    	 

	
		<div class="page-header">		
			<h1> 复合数据类型</h1>
		</div>    
	



<div class="row-fluid wiki">
	<!-- span -->
    
        <div class="span3 toc"></div>
        <div class="span9 note">
    

	

		<!-- content -->
		<h2 id="结构体">结构体</h2>
<h3 id="定义结构体">定义结构体</h3>
<p>例如，如果用实部和虚部表示一个复数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，我们可以写成由两个double型组成的结构体：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> complex_struct{</div><div class="line">    <span class="keyword">double</span> x, y;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>这一句定义了标识符<code>complex_struct</code>（同样遵循标识符的命名规则），这种标识符在C语言中称为Tag，<code>struct complex_struct { double x, y; }</code>整个可以看作一个类型名，就像int或double一样，只不过它是一个复合类型，如果用这个类型名来定义变量，可以这样写：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> complex_struct{</div><div class="line">    <span class="keyword">double</span> x, y;</div><div class="line">} z1, z2;</div></pre></td></tr></table></figure></p>
<p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>注意后面的<code>;</code>不能少。类型定义也是一种声明，声明都要以<code>;</code>号结尾。</p>
</div></p>
<p>也可以在定义了<code>complex_struct</code>后直接用普通的声明语句来声明 z1 和 z2：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> complex_struct z1, z2;</div></pre></td></tr></table></figure></p>
<h3 id="访问结构体成员">访问结构体成员</h3>
<p>每个复数变量都有两个成员（Member）x和y，可以用<code>.</code>运算符（<code>.</code>号，Period）来访问，这两个成员的存储空间是相邻的，合在一起组成复数变量的存储空间。看下面的例子：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">struct</span> complex_struct { <span class="keyword">double</span> x, y; } z;</div><div class="line">    <span class="keyword">double</span> x = <span class="number">3.0</span>;</div><div class="line">    z.x = x;</div><div class="line">    z.y = <span class="number">4.0</span>;</div><div class="line">    <span class="keyword">if</span> (z.y &lt; <span class="number">0</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"z=%f%fi\n"</span>, z.x, z.y);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"z=%f+%fi\n"</span>, z.x, z.y);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>注意上例中变量x和变量z的成员x的名字并不冲突，因为变量z的成员x只能通过表达式z.x来访问，编译器可以从语法上区分哪个x是变量x，哪个x是变量z的成员x。</p>
<h3 id="初始化和赋值">初始化和赋值</h3>
<p>结构体变量也可以在定义时初始化，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> complex_struct z = { <span class="number">3.0</span>, <span class="number">4.0</span> };</div></pre></td></tr></table></figure></p>
<p>Initializer中的数据依次赋给结构体的各成员。如果Initializer中的数据比结构体的成员多，编译器会报错，但如果只是末尾多个逗号则不算错。如果Initializer中的数据比结构体的成员少，未指定的成员将用0来初始化，就像未初始化的全局变量一样。例如以下几种形式的初始化都是合法的：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> x = <span class="number">3.0</span>;</div><div class="line"><span class="keyword">struct</span> complex_struct z1 = { x, <span class="number">4.0</span>, }; <span class="comment">/* z1.x=3.0, z1.y=4.0 */</span></div><div class="line"><span class="keyword">struct</span> complex_struct z2 = { <span class="number">3.0</span>, }; <span class="comment">/* z2.x=3.0, z2.y=0.0 */</span></div><div class="line"><span class="keyword">struct</span> complex_struct z3 = { <span class="number">0</span> }; <span class="comment">/* z3.x=0.0, z3.y=0.0 */</span></div></pre></td></tr></table></figure></p>
<p>注意，z1必须是局部变量才能用另一个变量x的值来初始化它的成员，如果是全局变量就只能用常量表达式来初始化。这也是C99的新特性，C89只允许在<code>{}</code>中使用常量表达式来初始化，无论是初始化全局变量还是局部变量。</p>
<p><code>{}</code>这种语法不能用于结构体的赋值，例如这样是错误的 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> complex_struct z1;</div><div class="line">z1 = { <span class="number">3.0</span>, <span class="number">4.0</span> };</div></pre></td></tr></table></figure></p>
<h3 id="实例：构造复数">实例：构造复数</h3>
<p>现在我们来实现一个完整的复数运算程序。在上一节我们已经定义了复数的结构体类型，现在需要围绕它定义一些函数。复数可以用直角坐标或极坐标表示，直角坐标做加减法比较方便，极坐标做乘除法比较方便。如果我们定义的复数结构体是直角坐标的，那么应该提供极坐标的转换函数，以便在需要的时候可以方便地取它的模和辐角。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> complex_struct {</div><div class="line">    <span class="comment">// 定义复数的结构体</span></div><div class="line">    <span class="keyword">double</span> x, y;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">double</span> real_part(<span class="keyword">struct</span> complex_struct z){</div><div class="line">    <span class="comment">// 返回复数的实部</span></div><div class="line">    <span class="keyword">return</span> z.x;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">double</span> img_part(<span class="keyword">struct</span> complex_struct z){</div><div class="line">    <span class="comment">// 返回复数的虚部</span></div><div class="line">    <span class="keyword">return</span> z.y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">double</span> magnitude(<span class="keyword">struct</span> complex_struct z){</div><div class="line">    <span class="comment">// 返回复数的模</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(z.x * z.x + z.y * z.y);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">double</span> angle(<span class="keyword">struct</span> complex_struct z){</div><div class="line">    <span class="comment">// 返回复数的辐角</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">atan2</span>(z.y, z.x);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> complex_struct make_from_real_img(<span class="keyword">double</span> x, <span class="keyword">double</span> y){</div><div class="line">    <span class="comment">// 用实部和虚部构造复数结构体</span></div><div class="line">    <span class="keyword">struct</span> complex_struct z;</div><div class="line">    z.x = x;</div><div class="line">    z.y = y;</div><div class="line">    <span class="keyword">return</span> z;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> complex_struct make_from_mag_ang(<span class="keyword">double</span> r, <span class="keyword">double</span> A){</div><div class="line">    <span class="comment">// 用辐角和模构造复数结构体</span></div><div class="line">    <span class="keyword">struct</span> complex_struct z;</div><div class="line">    z.x = r * <span class="built_in">cos</span>(A);</div><div class="line">    z.y = r * <span class="built_in">sin</span>(A);</div><div class="line">    <span class="keyword">return</span> z;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 定义复数的加减乘除运算</span></div><div class="line"><span class="keyword">struct</span> complex_struct add_complex(<span class="keyword">struct</span> complex_struct z1, <span class="keyword">struct</span> complex_struct z2){</div><div class="line">    <span class="keyword">return</span> make_from_real_img(</div><div class="line">        real_part(z1) + real_part(z2),</div><div class="line">    img_part(z1) + img_part(z2)</div><div class="line">    );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> complex_struct sub_complex(<span class="keyword">struct</span> complex_struct z1, <span class="keyword">struct</span> complex_struct z2){</div><div class="line">    <span class="keyword">return</span> make_from_real_img(</div><div class="line">        real_part(z1) - real_part(z2),</div><div class="line">    img_part(z1) - img_part(z2)</div><div class="line">    );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> complex_struct mul_complex(<span class="keyword">struct</span> complex_struct z1, <span class="keyword">struct</span> complex_struct z2){</div><div class="line">    <span class="keyword">return</span> make_from_mag_ang(</div><div class="line">        magnitude(z1) * magnitude(z2),</div><div class="line">    angle(z1) + angle(z2)</div><div class="line">    );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> complex_struct div_complex(<span class="keyword">struct</span> complex_struct z1, <span class="keyword">struct</span> complex_struct z2){</div><div class="line">    <span class="keyword">return</span> make_from_mag_ang(</div><div class="line">        magnitude(z1) / magnitude(z2),</div><div class="line">    angle(z1) - angle(z2)</div><div class="line">    );</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>可以看出，复数加减乘除运算的实现并没有直接访问结构体 complex_struct 的成员x和y，而是把它看成一个整体，通过调用相关函数来取它的直角坐标和极坐标。这样就可以非常方便地替换掉结构体 complex_struct 的存储表示，例如改为用极坐标来存储。</p>
<h3 id="嵌套结构体">嵌套结构体</h3>
<p>结构体也是一种递归定义：结构体的成员具有某种数据类型，而结构体本身也是一种数据类型。换句话说，结构体的成员可以是另一个结构体，即结构体可以嵌套定义。例如我们在复数的基础上定义复平面上的线段：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Segment {</div><div class="line">    <span class="keyword">struct</span> complex_struct start;</div><div class="line">    <span class="keyword">struct</span> complex_struct end;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<h4 id="初始化">初始化</h4>
<p>嵌套结构体可以嵌套地初始化，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Segment s = { {<span class="number">1.0</span>, <span class="number">2.0</span> }, { <span class="number">4.0</span>, <span class="number">6.0</span> } };</div></pre></td></tr></table></figure></p>
<p>也可以平坦（Flat）地初始化。例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Segment s = { <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span> };</div></pre></td></tr></table></figure></p>
<p>甚至可以把两种方式混合使用（这样可读性很差，应该避免）：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Segment s = { { <span class="number">1.0</span>, <span class="number">2.0</span> }, <span class="number">4.0</span>, <span class="number">6.0</span> };</div></pre></td></tr></table></figure></p>
<p>利用C99的新特性也可以做 Memberwise Initialization，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Segment s = { .start.x = <span class="number">1.0</span>, .end.x = <span class="number">2.0</span> };</div></pre></td></tr></table></figure></p>
<h4 id="访问结构体成员-v2">访问结构体成员</h4>
<p>访问嵌套结构体的成员要用到多个<code>.</code>运算符，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s.start.t = RECTANGULAR;</div><div class="line">s.start.a = <span class="number">1.0</span>;</div><div class="line">s.start.b = <span class="number">2.0</span>;</div></pre></td></tr></table></figure></p>
<h2 id="枚举">枚举</h2>
<h3 id="定义">定义</h3>
<p>enum关键字的作用和struct关键字类似，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> coordinate_type { RECTANGULAR, POLAR };</div></pre></td></tr></table></figure></p>
<p><code>enum coordinate_type</code> 表示一个枚举（Enumeration）类型。<strong>枚举类型的成员是常量</strong>，它们的值由编译器自动分配，例如定义了上面的枚举类型之后，RECTANGULAR就表示常量0，POLAR表示常量1。如果不希望从0开始分配，可以这样定义：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> coordinate_type { RECTANGULAR = <span class="number">1</span>, POLAR };</div></pre></td></tr></table></figure></p>
<p>这样，RECTANGULAR就表示常量1，而POLAR表示常量2。枚举常量也是一种整型，其值在编译时确定，因此也可以出现在常量表达式中，可以用于初始化全局变量或者作为case分支的判断条件。</p>
<p>有一点需要注意，虽然结构体的成员名和变量名不在同一命名空间中，但枚举的成员名却和变量名在同一命名空间中，所以会出现命名冲突。例如这样是不合法的：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">enum</span> coordinate_type { RECTANGULAR = <span class="number">1</span>, POLAR };</div><div class="line">    <span class="keyword">int</span> RECTANGULAR;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, RECTANGULAR, POLAR);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="赋值">赋值</h3>
<p>枚举类型的对象的初始化或赋值，只能通过其枚举成员或同一枚举类型的其他对象来进行，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Points pt3d = point3d;      <span class="comment">//合法</span></div><div class="line">Points pt2w = <span class="number">3</span>;            <span class="comment">//不合法：pt2w不能再初始化</span></div><div class="line">pt2w = polygon;             <span class="comment">//不合法：polygon不是Points的枚举成员</span></div><div class="line">pt2w = pt3d;                <span class="comment">//合法</span></div></pre></td></tr></table></figure></p>
<p>注意把 3 赋给 Points 对象是非法的，即使 3 与一个 Points 枚举成员相关联。</p>
<h3 id="实例">实例</h3>
<p>可以对在上一节中的 complex_struct 进行改进，让其同时支持两种直角坐标和极坐标两种存储格式，方法是为 complex_struct 结构体添加一个枚举常量用作数据类型标志：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> coordinate_type {RECTANGULAR, POLAR};</div><div class="line"><span class="keyword">struct</span> complex_struct {</div><div class="line">    <span class="keyword">enum</span> coordinate_type t;</div><div class="line">    <span class="keyword">double</span> a, b;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> complex_struct make_from_real_img(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> complex_struct z;</div><div class="line">    z.t = RECTANGULAR;</div><div class="line">    z.a = x;</div><div class="line">    z.b = y;</div><div class="line">    <span class="keyword">return</span> z;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> complex_struct make_from_mag_ang(<span class="keyword">double</span> r, <span class="keyword">double</span> A)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> complex_struct z;</div><div class="line">    z.t = POLAR;</div><div class="line">    z.a = r;</div><div class="line">    z.b = A;</div><div class="line">    <span class="keyword">return</span> z;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 其他的加减乘除运算...</span></div></pre></td></tr></table></figure></p>
<p>如果数据类型标志为0，那么两个浮点数就表示直角坐标，如果数据类型标志为1，那么两个浮点数就表示极坐标。这样，直角坐标和极坐标的数据都可以适配（Adapt）到 complex_struct 结构体中，无需转换和损失精度。</p>
<h2 id="数组">数组</h2>
<p>数组（Array）也是一种复合数据类型，它由一系列相同类型的元素（Element）组成。</p>
<h3 id="定义数组">定义数组</h3>
<h4 id="简单数组">简单数组</h4>
<p>例如定义一个由4个int型元素组成的数组count：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count[<span class="number">4</span>];</div></pre></td></tr></table></figure></p>
<p>和<a href="/wiki/c-compound-type.html">结构体</a>成员类似，数组count的4个元素的存储空间也是相邻的。</p>
<h4 id="定义复合类型数组">定义复合类型数组</h4>
<p>结构体成员可以是基本数据类型，也可以是复合数据类型，数组中的元素也是如此。根据组合规则，我们可以定义一个由4个结构体元素组成的数组：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> complex_struct {</div><div class="line">    <span class="keyword">double</span> x, y;</div><div class="line">} a[<span class="number">4</span>];</div></pre></td></tr></table></figure></p>
<h3 id="访问数组元素">访问数组元素</h3>
<p>数组中的元素通过下标（或者叫索引，Index）来访问。例如前面定义的由4个int型元素组成的数组count图示如下：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">         0      1      2       3</div><div class="line">      +------|------|------|------+</div><div class="line">      |      |      |      |      |</div><div class="line">count |  0   |  0   |  0   |  0   |</div><div class="line">      +------|------|------|------+</div></pre></td></tr></table></figure></p>
<p>整个数组占了4个int型的存储单元，存储单元用小方框表示，里面的数字是存储在这个单元中的数据（假设都是0），而框外面的数字是下标，这四个单元分别用count[0]、count[1]、count[2]、count[3]来访问。</p>
<p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>和我们平常数数的习惯不同，数组元素是从“0”开始数的。大多数编程语言都是这么规定的，所以计算机术语中有 Zeroth 这个词。</p>
</div></p>
<p>这种数组下标的表达式不仅可以表示存储单元中的值，也可以表示存储单元本身，也就是说可以做左值，因此以下语句都是正确的：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">count[<span class="number">0</span>] = <span class="number">7</span>;</div><div class="line">count[<span class="number">1</span>] = count[<span class="number">0</span>] * <span class="number">2</span>;</div><div class="line">++count[<span class="number">2</span>];</div></pre></td></tr></table></figure></p>
<p>数组下标也可以是表达式，但表达式的值必须是整型的。例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">count[i] = count[i+<span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p><div class="alert alert-error"><i class="fa fa-bug"></i>  <p>使用数组下标不能超出数组的长度范围，这一点在使用变量做数组下标时尤其要注意。<strong>C编译器并不检查count[-1]或是count[100]这样的访问越界错误</strong>，编译时能顺利通过，所以属于运行时错误。但有时候这种错误很隐蔽，发生访问越界时程序可能并不会立即崩溃，而执行到后面某个正确的语句时却有可能突然崩溃。所以从一开始写代码时就要小心避免出问题，事后依靠调试来解决问题的成本是很高的。</p>
</div></p>
<h3 id="初始化-v2">初始化</h3>
<p>数组也可以像结构体一样初始化，未赋初值的元素也是用0来初始化，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count[<span class="number">4</span>] = { <span class="number">3</span>, <span class="number">2</span>, };</div></pre></td></tr></table></figure></p>
<p>则count[0]等于3， count[1]等于2，后面两个元素等于0。如果定义数组的同时初始化它，也可以不指定数组的长度，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count[] = { <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, };</div></pre></td></tr></table></figure></p>
<p>编译器会根据Initializer有三个元素确定数组的长度为3。利用C99的新特性也可以做 Memberwise Initialization：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count[<span class="number">4</span>] = { [<span class="number">2</span>] = <span class="number">3</span> };</div></pre></td></tr></table></figure></p>
<h3 id="示例">示例</h3>
<p>下面举一个完整的例子：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> count[<span class="number">4</span>] = { <span class="number">3</span>, <span class="number">2</span>, }, i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"count[%d]=%d\n"</span>, i, count[i]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="多维数组">多维数组</h3>
<p>就像结构体可以嵌套一样，数组也可以嵌套，一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional Array）。例如定义并初始化一个二维数组：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</div></pre></td></tr></table></figure></p>
<p>数组a有3个元素，a[0]、a[1]、a[2]。每个元素也是一个数组，例如a[0]是一个数组，它有两个元素a[0][0]、a[0][1]，这两个元素的类型是int，值分别是1、2，同理，数组a[1]的两个元素是3、4，数组a[2]的两个元素是5、0。如下图所示：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">        0    1</div><div class="line">      +----|----+</div><div class="line"> 概 0 | 1  | 2  |</div><div class="line"> 念   +----|----+</div><div class="line"> 模 1 | 3  | 4  |</div><div class="line"> 型   +----|----+</div><div class="line">    3 | 5  | 0  |</div><div class="line">      +----|----+</div><div class="line"></div><div class="line">物理模型</div><div class="line"> a[0][0]   a[1][0]  a[2][0]</div><div class="line"> +----|----|----|----|----|----+</div><div class="line"> | 1  | 2  | 3  | 4  | 5  | 0  |</div><div class="line"> +----|----|----|----|----|----+</div><div class="line">     a[0][1]    a[1][1]   a[2][1]</div></pre></td></tr></table></figure></p>
<p>从概念模型上看，这个二维数组是三行两列的表格，元素的两个下标分别是行号和列号。从物理模型上看，这六个元素在存储器中仍然是连续存储的，就像一维数组一样，相当于把概念模型的表格一行一行接起来拼成一串，C语言的这种存储方式称为<strong>Row-major</strong>方式，而有些编程语言（例如FORTRAN）是把概念模型的表格一列一列接起来拼成一串存储的，称为<strong>Column-major</strong>方式。</p>
<p>多维数组也可以像嵌套结构体一样用嵌套Initializer初始化，例如上面的二维数组也可以这样初始化：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[][<span class="number">2</span>] = { { <span class="number">1</span>, <span class="number">2</span> },</div><div class="line">        { <span class="number">3</span>, <span class="number">4</span> },</div><div class="line">        { <span class="number">5</span>, } };</div></pre></td></tr></table></figure></p>
<p>注意，<strong>除了第一维的长度可以由编译器自动计算而不需要指定，其余各维都必须明确指定长度</strong>。</p>
<p>利用C99的新特性也可以做 Memberwise Initialization，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = { [<span class="number">0</span>][<span class="number">1</span>] = <span class="number">9</span>, [<span class="number">2</span>][<span class="number">1</span>] = <span class="number">8</span> };</div></pre></td></tr></table></figure></p>
<h2 id="字符串">字符串</h2>
<p>字符串可以看作一个数组，它的每个元素是字符型的，例如字符串&quot;Hello, world.\n&quot;图示如下：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+----|----|----|----|----|---------|----|----|----|----|----|----|----|----+</div><div class="line">| h  | e  | l  | l  | o  | ,  |    | w  | o  | r  | l  | d  | .  | \n | \0 | </div><div class="line">+----|----|----|----|----|----|----|----|----|----|----|----|----|----|----+</div></pre></td></tr></table></figure></p>
<p>注意每个字符串末尾都有一个字符<code>\0</code>做结束符，这里的\0是ASCII码的八进制表示，也就是ASCII码为0的Null字符，在C语言中这种字符串也称为以零结尾的字符串（Null-terminated String）。数组元素可以通过数组名加下标的方式访问，而字符串字面值也可以像数组名一样使用，可以加下标访问其中的字符：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> c = <span class="string">"Hello, world.\n"</span>[<span class="number">0</span>];</div></pre></td></tr></table></figure></p>
<h3 id="初始化-v3">初始化</h3>
<p>字符数组也可以用一个字符串字面值来初始化：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">"Hello"</span>;</div></pre></td></tr></table></figure></p>
<p>相当于</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = { <span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span> };</div></pre></td></tr></table></figure></p>
<p>str的后四个元素没有指定，自动初始化为0，即Null字符。注意，虽然字符串字面值&quot;Hello&quot;是只读的，但用它初始化的数组str却是可读可写的。数组str中保存了一串字符，以’\0’结尾，也可以叫字符串。在本书中只要是以Null字符结尾的一串字符都叫字符串，不管是像str这样的数组，还是像&quot;Hello&quot;这样的字符串字面值。</p>
<p>如果用于初始化的字符串字面值比数组还长，比如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">"Hello, world.\n"</span>;</div></pre></td></tr></table></figure></p>
<p>则数组str只包含字符串的前10个字符，不包含Null字符，这种情况编译器会给出警告。如果要用一个字符串字面值准确地初始化一个字符数组，最好的办法是不指定数组的长度，让编译器自己计算：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> str[] = <span class="string">"Hello, world.\n"</span>;</div></pre></td></tr></table></figure></p>
<p>字符串字面值的长度包括Null字符在内一共15个字符，编译器会确定数组str的长度为15。</p>
<p>有一种情况需要特别注意，如果用于初始化的字符串字面值比数组刚好长出一个Null字符的长度，比如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> str[<span class="number">14</span>] = <span class="string">"Hello, world.\n"</span>;</div></pre></td></tr></table></figure></p>
<p>则数组str不包含Null字符，并且编译器不会给出警告。</p>
<h3 id="多维字符数组">多维字符数组</h3>
<p>多维字符数组也可以嵌套使用字符串字面值做Initializer，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> print_day(<span class="keyword">int</span> day)</div><div class="line">{</div><div class="line">    <span class="keyword">char</span> days[<span class="number">8</span>][<span class="number">10</span>] = { <span class="string">""</span>, <span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>,</div><div class="line">                 <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>,</div><div class="line">                 <span class="string">"Saturday"</span>, <span class="string">"Sunday"</span> };</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (day &lt; <span class="number">1</span> || day &gt; <span class="number">7</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Illegal day number!\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, days[day]);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    print_day(<span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>这个程序中定义了一个多维字符数组char days[8][10];，为了使1~7刚好映射到days[1]~days[7]，我们把days[0]空出来不用，所以第一维的长度是8，为了使最长的字符串&quot;Wednesday&quot;能够保存到一行，末尾还能多出一个Null字符的位置，所以第二维的长度是10。</p>
<h2 id="类型总结">类型总结</h2>
<p><img src="/images/c-compound-type/pointer.type.gif" alt="C语言类型总结"></p>
<p>C语言的类型分为函数类型、对象类型和不完全类型三大类。对象类型又分为标量类型和非标量类型。指针类型属于标量类型，因此也可以做逻辑与、或、非运算的操作数和if、for、while的控制表达式，NULL指针表示假，非NULL指针表示真。不完全类型是暂时没有完全定义好的类型，编译器不知道这种类型该占几个字节的存储空间，例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s;</div><div class="line"><span class="keyword">union</span> u;</div><div class="line"><span class="keyword">char</span> str[];</div></pre></td></tr></table></figure></p>
<p>具有不完全类型的变量可以通过多次声明组合成一个完全类型，比如数组str声明两次：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> str[];</div><div class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</div></pre></td></tr></table></figure></p>
<p>当编译器碰到第一个声明时，认为str是一个不完全类型，碰到第二个声明时str就组合成完全类型了，如果编译器处理到程序文件的末尾仍然无法把str组合成一个完全类型，就会报错。</p>
<h3 id="不完全的结构体类型">不完全的结构体类型</h3>
<p>不完全的结构体类型有重要作用：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s {</div><div class="line">    <span class="keyword">struct</span> t *pt;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> t {</div><div class="line">    <span class="keyword">struct</span> s *ps;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>struct s和struct t各有一个指针成员指向另一种类型。编译器从前到后依次处理，当看到<code>struct s { struct t* pt; };</code>时，认为struct t是一个不完全类型，pt是一个指向不完全类型的指针，尽管如此，这个指针却是完全类型，因为<strong>不管什么指针都占4个字节存储空间</strong>，这一点很明确。然后编译器又看到<code>struct t { struct s *ps; };</code>，这时struct t有了完整的定义，就组合成一个完全类型了，pt的类型就组合成一个指向完全类型的指针。由于struct s在前面有完整的定义，所以<code>struct s *ps;</code>也定义了一个指向完全类型的指针。</p>
<p>这样的类型定义是错误的：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s {</div><div class="line">    <span class="keyword">struct</span> t ot;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> t {</div><div class="line">    <span class="keyword">struct</span> s os;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>编译器看到<code>struct s { struct t ot; };</code>时，认为struct t是一个不完全类型，无法定义成员ot，因为不知道它该占几个字节。所以结构体中可以递归地定义指针成员，但不能递归地定义变量成员，你可以设想一下，假如允许递归地定义变量成员，struct s中有一个struct t，struct t中又有一个struct s，struct s又中有一个struct t，这就成了一个无穷递归的定义。</p>
<h4 id="一个结构体的递归定义">一个结构体的递归定义</h4>
<p>以上是两个结构体构成的递归定义，一个结构体也可以递归定义：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s {</div><div class="line">    <span class="keyword">char</span> data[<span class="number">6</span>];</div><div class="line">    <span class="keyword">struct</span> s* next;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>当编译器处理到第一行struct s {时，认为struct s是一个不完全类型，当处理到第三行struct s *next;时，认为next是一个指向不完全类型的指针，当处理到第四行};时，struct s成了一个完全类型，next也成了一个指向完全类型的指针。类似这样的结构体是很多种数据结构的基本组成单元，如链表、二叉树等。</p>
<h3 id="分析复杂的类型">分析复杂的类型</h3>
<p>可以想像得到，如果把指针和数组、函数、结构体层层组合起来可以构成非常复杂的类型。在分析复杂声明时，要<strong>借助typedef把复杂声明分解成几种基本形式</strong>：</p>
<ul>
<li><code>T *p;</code>，p是指向T类型的指针。</li>
<li><code>T a[];</code>，a是由T类型的元素组成的数组，但有一个例外，如果a是函数的形参，则相当于T *a;</li>
<li><code>T1 f(T2, T3...);</code>，f是一个函数，参数类型是T2、T3等等，返回值类型是T1。</li>
</ul>
<p>我们分解一下这个复杂声明：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*(*fp)(<span class="keyword">void</span> *))[<span class="number">10</span>];</div></pre></td></tr></table></figure></p>
<ol>
<li>fp和*号括在一起，说明fp是一个指针，指向T1类型：</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (*T1(<span class="keyword">void</span> *))[<span class="number">10</span>];</div><div class="line">T1 *fp;</div></pre></td></tr></table></figure></p>
<ol start="2">
<li>T1应该是一个函数类型，参数是void *，返回值是T2类型：</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (*T2)[<span class="number">10</span>];</div><div class="line"><span class="keyword">typedef</span> T2 T1(<span class="keyword">void</span> *);</div><div class="line">T1 *fp;</div></pre></td></tr></table></figure></p>
<ol start="3">
<li>T2和*号括在一起，应该也是个指针，指向T3类型：</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T3[<span class="number">10</span>];</div><div class="line"><span class="keyword">typedef</span> T3 *T2;</div><div class="line"><span class="keyword">typedef</span> T2 T1(<span class="keyword">void</span> *);</div><div class="line">T1 *fp;</div></pre></td></tr></table></figure></p>
<p>显然，T3是一个int数组，由10个元素组成。分解完毕。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>C99已经定义了复数类型Complex，位于C标准库的头文件complex.h <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p>在 C99 后支持使用一种新的语法语法 Compound Literal，例如：<code>z1 = (struct complex_struct){3.0, 4.0};</code>。 <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>


		<!-- pagination -->
		<div>
		<center>
		<div class="pagination">
<ul class="pagination">
	
	
	
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
			
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
			
			
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	
		<li class="prev"><a data-pjax href="/wiki/c-primitive-type.html" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
	
	<li><a data-pjax href="/wiki"><i class="fa fa-tasks"></i>Wiki</a></li>
	
		<li class="next"><a data-pjax href="/wiki/c-const.html" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

	    </center>
		</div>
				
		<!-- toc -->
		
   	<script type="text/javascript">
		jQuery(document).ready(function() {
		
 		   generateWikiTOC('.note', '.toc',  2 , 2 );
		
		});
	</script>



				
		<!-- comment -->
		
<section id="comment">
    <h2 class="title">Comments</h2>
	
	 <div id="comment-thread"></div>
	 <div id="loading-spin"></div>
	 <script type="text/javascript">
	   getComments({
		       type: "github",
	           user: "wzpan",
	           repo: "wzpan.github.io",
			   client_id: "1eb35434de75c06a513f",
			   client_secret: "6e4193f8ecd619cdfac2b1aa16b3663fe18d2e90",
			   no_comment: "暂时还没有留言呢，点击下面的按钮去留言吧！",
			   go_to_comment: "去留言",
			   btn_class: "btn btn-primary",
			   no_issue: "no_issue",
			   issue_title: "复合数据类型",
			   issue_id: "undefined",
			   comments_target: "#comment-thread" ? "#comment-thread" : "#comment-thread",
			   loading_target: "undefined"
			   });
	 </script>
	
</section>


		

	</div> <!-- span9/span12 -->
</div><!-- row-fluid post-full -->

	</div>	
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2019 Joseph Pan
  
    <small>
     <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"><img title="知识共享许可协议" style="border-width: 0px; vertical-align: middle; display: inline; " src="/images/license.png"></a>
    </small>
</p>
 </footer>
</div> <!-- container-narrow -->


<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/dist/jquery.imagesloaded.min.js"></script>


<script src="/dist/gallery.min.js"></script>
<script src="/dist/bootstrap.min.js"></script>
<script src="/dist/jquery.tableofcontents.min.js"></script>
<script src="/dist/tocgenerator.min.js"></script>
<script src="/dist/require.min.js"></script>
<script src="/dist/main.min.js"></script>



<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox({
    helpers : { 
        title : { type : 'inside' }
    },
    afterLoad : function() {
        this.title = (this.title ? '' + this.title + '<br />' : '') + 'Image ' + (this.index + 1) + ' of ' + this.group.length;
    }
  });
})(jQuery);
</script>




<!-- syntax highlighting -->

  <script>
  marked.setOptions({
    highlight: function (code, lang) {
        return hljs.highlightAuto(code).value;
    }
  });
  function Highlighting(){
    var markdowns = document.getElementsByClassName('markdown');
    for(var i=0;i<markdowns.length;i++){
        if(markdowns[i].innerHTML) markdowns[i].innerHTML =marked(markdowns[i].innerHTML);
    }
  }
  window.addEventListener('DOMContentLoaded', Highlighting, false);
  window.addEventListener('load', Highlighting, false);
  </script>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','ney3Rb77vMaWT2KUKFyt');
</script>



</body>
</html>
