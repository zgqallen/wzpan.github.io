<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ES6 | HaHack</title>
  <meta name="author" content="Joseph Pan">
  
  <meta name="description" content="ECMAScript 6.0（以下简称ES6）就是 ECMA 在 2015 年推出的 JavaScript 语言的下一代标准。
兼容程度
各大浏览器的最新版本，对ES6的支持可以查看 kangax.github.io/es5-compat-table/es6/ 。
Node.js是JavaScrip">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="ES6"/>
  <meta property="og:site_name" content="HaHack"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/images/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="HaHack" type="application/atom+xml">
  
  <link rel="stylesheet" href="/dist/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/bootstrap-responsive.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/font-awesome.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/style.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/highlight.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/sidenav.min.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/dist/responsive.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/bubble.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/google-fonts.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/nprogress.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/comment.min.css" media="screen" type="text/css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <!--[if lte IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

<!--  -->
<!--     <link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow|PT+Sans:400,400italic,700,700italic|Droid+Serif:400,400italic' rel='stylesheet' type='text/css'> -->
<!--     <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'> -->
<!--  -->
  
<script src="/dist/jquery-2.0.3.min.js"></script>


    <script src="/dist/videoGFW.min.js"></script>
	
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-41569408-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;

ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';

var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

	


    <link rel="stylesheet" href="/dist/highlight-default.min.css" media="screen" type="text/css">
    
    <script src="/dist/comment.min.js"></script>
    <script src="/dist/marked.min.js"></script>
    
    <script src="/dist/highlight.min.js"></script>
    <script src="/dist/timeago.min.js"></script>
	<script src="/dist/spin.min.js"></script>


</head>


<body data-spy="scroll" data-target=".toc">  
  <header id="header" class="inner"><div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
            <a data-pjax class="brand" href="/">HaHack</a>
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <div class="nav-collapse collapse">
            <ul class="nav">				
			    
				   <li><a data-pjax href="/archive" title="所有文章归档"><i class="fa fa-archive"></i>Archive</a></li>
    			
				   <li><a data-pjax href="/categories" title="所有文章分类"><i class="fa fa-folder"></i>Categories</a></li>
    			
				   <li><a data-pjax href="/tags" title="所有文章标签"><i class="fa fa-tags"></i>Tags</a></li>
    			
				
				<li class="divider-vertical"></li>
			   	<li><a data-pjax href="/wiki" title="我的笔记库"><i class="fa fa-tasks"></i>wiki</a></li>				   
				
            </ul>			
			<ul class="nav navright">
				<li class="dropdown works">
				<a data-pjax href="#" title="作品集" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-th-large"></i>Works <b class="caret"></b></a>
                <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">				
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/wukong-robot" title="wukong-robot 是一个简单、灵活、优雅的中文语音对话机器人。"><i class="fab fa-github"></i>wukong-robot</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/dingdang-robot/dingdang-robot" title="叮当是一款可以工作在 Raspberry Pi 上的中文语音对话机器人/智能音箱项目。"><i class="fab fa-github"></i>dingdang-robot</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/comment-js" title="纯JS实现的静态站点评论系统，使用 Github/OSChina 作为 backend。"><i class="fab fa-github"></i>comment.js</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/qtevm" title="首个完整的 C++ 开源实现，能同时放大动作变化和颜色变化"><i class="fab fa-github"></i>QtEVM</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/hexo-series" title="为 Hexo 写的一系列主题/工具/插件"><i class="fab fa-github"></i>hexo-series</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/scnu/scnuthesis" title="符合华南师范大学硕士/博士学位论文格式要求的LaTeX模板。"><i class="fab fa-github"></i>SCNUThesis</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/slides" title="一些幻灯片作品"><i class="fab fa-github"></i>Slides</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://hahack.com/codes/fcevm/" title="硕士毕业论文"><i class="fab fa-github"></i>Dissertation</a></li>
				
                </ul>                
				</li>
                <li class="dropdown works">
				<a data-pjax href="#" title="课程" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-video"></i>Courses <b class="caret"></b></a>
                <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">
                
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/list/python%20next%20潘伟洲" title="Python 从入门到实践系列"><i class="fa fa-video"></i>Python</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/326820" title="微信小游戏入门与实战"><i class="fa fa-video"></i>minigame</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/350627" title="使用Cocos Creator开发微信小游戏《2048》"><i class="fa fa-video"></i>2048</a></li>
				
                </ul>                
				</li>                
				<li class="dropdown">
				<a data-pjax href="#" title="订阅本站" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-rss"></i>Subscribe <b class="caret"></b></a>
                                <ul class="dropdown-menu" role="menu" aria-labelledby="drop2">
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="/atom.xml" title="使用 RSS 阅读器订阅 HaHack"><i class="fa fa-rss-square"></i>RSS</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="/wechat.html" title="订阅 HaHack 的公众平台"><i class="fa fa-qrcode"></i>WeChat</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="http://toutiao.io/u/147640" title=""><i class="fa fa-align-justify"></i>Toutiao</a></li>
				
                	        </ul>
				</li>
				
				<li><a data-pjax href="/about" title="关于我"><i class="fa fa-user"></i>About</a></li>				   				
   					  
            </ul>
            </div> <!-- nav-collapse collapse -->
        </div> <!-- container -->
     </div> <!-- navbar-inner -->
</div> <!-- navbar navbar-inverse -->
</header>
  <div class="container" id="container">
  	<div class="content">
    	 

	
		<div class="page-header">		
			<h1> ES6</h1>
		</div>    
	



<div class="row-fluid wiki">
	<!-- span -->
    
        <div class="span3 toc"></div>
        <div class="span9 note">
    

	

		<!-- content -->
		<p>ECMAScript 6.0（以下简称ES6）就是 ECMA 在 2015 年推出的 JavaScript 语言的下一代标准。</p>
<h2 id="兼容程度">兼容程度</h2>
<p>各大浏览器的最新版本，对ES6的支持可以查看 <a href="http://kangax.github.io/es5-compat-table/es6/" target="_blank" rel="external">kangax.github.io/es5-compat-table/es6/</a> 。</p>
<p>Node.js是JavaScript语言的服务器运行环境，对ES6的支持度比浏览器更高。通过Node，可以体验更多ES6的特性。建议使用版本管理工具<a href="/wiki/javascript-tools.html#nvm">nvm</a>，来安装Node，因为可以自由切换版本。</p>
<p>使用下面的命令，可以查看Node所有已经实现的ES6特性：</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ node --v8-options | grep harmony</div><div class="line"></div><div class="line">-<span class="ruby">-harmony_typeof</span></div><div class="line">-<span class="ruby">-harmony_scoping</span></div><div class="line">-<span class="ruby">-harmony_modules</span></div><div class="line">-<span class="ruby">-harmony_symbols</span></div><div class="line">-<span class="ruby">-harmony_proxies</span></div><div class="line">-<span class="ruby">-harmony_collections</span></div><div class="line">-<span class="ruby">-harmony_observation</span></div><div class="line">-<span class="ruby">-harmony_generators</span></div><div class="line">-<span class="ruby">-harmony_iteration</span></div><div class="line">-<span class="ruby">-harmony_numeric_literals</span></div><div class="line">-<span class="ruby">-harmony_strings</span></div><div class="line">-<span class="ruby">-harmony_arrays</span></div><div class="line">-<span class="ruby">-harmony_maths</span></div><div class="line">-<span class="ruby">-harmony</span></div></pre></td></tr></table></figure></p>
<p><a href="/wiki/javascript-tools.html#babel-%E8%BD%AC%E7%A0%81%E5%99%A8">Babel</a>是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。</p>
<p>Facebook 的 React Native 同样使用 babel ，以支持 ES5、ES6、ES7 的部分语法特性。见 <a href="https://github.com/facebook/react-native/blob/0.30-stable/docs/JavaScriptEnvironment.md" target="_blank" rel="external">React Native - JavaScript Runtime</a>。</p>
<h2 id="let-和-const">let 和 const</h2>
<h3 id="let">let</h3>
<p>ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line">}</div><div class="line"></div><div class="line">a <span class="comment">// ReferenceError: a is not defined.</span></div><div class="line">b <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p>
<p>for循环的计数器，就很合适使用let命令。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {}</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line"><span class="comment">//ReferenceError: i is not defined</span></div></pre></td></tr></table></figure></p>
<p>上面代码的计数器i，只在for循环体内有效。</p>
<p>下面的代码如果使用var，最后输出的是10。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">a[i] = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line">};</div><div class="line">}</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。</p>
<p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">a[i] = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line">};</div><div class="line">}</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。</p>
<h4 id="不存在变量提升">不存在变量提升</h4>
<p>let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></div><div class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h4 id="暂时性死区">暂时性死区</h4>
<p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</div><div class="line">tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">let</span> tmp;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
<p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</div><div class="line"><span class="comment">// TDZ开始</span></div><div class="line">tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line"><span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></div><div class="line"><span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></div><div class="line"></div><div class="line">tmp = <span class="number">123</span>;</div><div class="line"><span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。</p>
<p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">let</span> x;</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个ReferenceError。</p>
<p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>
<p>有些“死区”比较隐蔽，不太容易发现。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(x = y, y = 2)</span> </span>{</div><div class="line"><span class="keyword">return</span> [x, y];</div><div class="line">}</div><div class="line"></div><div class="line">bar(); <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(x = 2, y = x)</span> </span>{</div><div class="line"><span class="keyword">return</span> [x, y];</div><div class="line">}</div><div class="line">bar(); <span class="comment">// [2, 2]</span></div></pre></td></tr></table></figure></p>
<p>ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。
总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h4 id="不允许重复声明">不允许重复声明</h4>
<p>let不允许在相同作用域内，重复声明同一个变量。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>因此，不能在函数内部重新声明参数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(arg)</span> </span>{</div><div class="line"><span class="keyword">let</span> arg; <span class="comment">// 报错</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(arg)</span> </span>{</div><div class="line">{</div><div class="line"><span class="keyword">let</span> arg; <span class="comment">// 不报错</span></div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="块级作用域">块级作用域</h3>
<p>let实际上为JavaScript新增了块级作用域。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">let</span> n = <span class="number">5</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</div><div class="line"><span class="keyword">let</span> n = <span class="number">10</span>;</div><div class="line">}</div><div class="line"><span class="built_in">console</span>.log(n); <span class="comment">// 5</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。</p>
<p>ES6允许块级作用域的任意嵌套。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{{{{{<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>}}}}};</div></pre></td></tr></table></figure></p>
<p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">{{{{</div><div class="line">{<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>}</div><div class="line"><span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></div><div class="line">}}}};</div></pre></td></tr></table></figure></p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">{{{{</div><div class="line"><span class="keyword">let</span> insane = <span class="string">'Hello World'</span>;</div><div class="line">{<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>}</div><div class="line">}}}};</div></pre></td></tr></table></figure></p>
<p>块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IIFE写法</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="keyword">var</span> tmp = ...;</div><div class="line">...</div><div class="line">}());</div><div class="line"></div><div class="line"><span class="comment">// 块级作用域写法</span></div><div class="line">{</div><div class="line"><span class="keyword">let</span> tmp = ...;</div><div class="line">...</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="const命令">const命令</h3>
<p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</div><div class="line">PI <span class="comment">// 3.1415</span></div><div class="line"></div><div class="line">PI = <span class="number">3</span>;</div><div class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></div></pre></td></tr></table></figure></p>
<p>上面代码表明改变常量的值会报错。</p>
<p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo;</div><div class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></div></pre></td></tr></table></figure></p>
<p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p>
<p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</div><div class="line"><span class="keyword">const</span> MAX = <span class="number">5</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">MAX <span class="comment">// Uncaught ReferenceError: MAX is not defined</span></div></pre></td></tr></table></figure></p>
<p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</div><div class="line"><span class="built_in">console</span>.log(MAX); <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">const</span> MAX = <span class="number">5</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码在常量MAX声明之前就调用，结果报错。</p>
<p>const声明的常量，也与let一样不可重复声明。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span>;</div><div class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line"><span class="comment">// 以下两行都会报错</span></div><div class="line"><span class="keyword">const</span> message = <span class="string">"Goodbye!"</span>;</div><div class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</div></pre></td></tr></table></figure></p>
<p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。<strong>const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心</strong>。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = {};</div><div class="line">foo.prop = <span class="number">123</span>;</div><div class="line"></div><div class="line">foo.prop</div><div class="line"><span class="comment">// 123</span></div><div class="line"></div><div class="line">foo = {}; <span class="comment">// TypeError: "foo" is read-only</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = [];</div><div class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></div><div class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></div><div class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p>
<p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<pre><code class="language-javascript">const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
</code></pre>
<p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code class="language-javascript">var constantize = (obj) =&gt; {
Object.freeze(obj);
Object.keys(obj).forEach( (key, value) =&gt; {
if ( typeof obj[key] === 'object' ) {
constantize( obj[key] );
}
});
};
</code></pre>
</div></p>
<p>ES5之前只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。</p>
<h3 id="全局对象的属性">全局对象的属性</h3>
<p>全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</div><div class="line">a <span class="comment">// 1</span></div><div class="line"></div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，全局对象的属性赋值与全局变量的赋值，是同一件事。（对于Node来说，这一条只对REPL环境适用，模块环境之中，全局变量必须显式声明成global对象的属性。）</p>
<p>未声明的全局变量，自动成为全局对象window的属性，这被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了两个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道，其次程序员很容易不知不觉地就创建了全局变量（比如打字出错）。另一方面，从语义上讲，语言的顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="comment">// 如果在Node的REPL环境，可以写成global.a</span></div><div class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></div><div class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，全局变量a由var命令声明，所以它是全局对象的属性；全局变量b由let命令声明，所以它不是全局对象的属性，返回undefined。</p>
<h2 id="变量的解构赋值">变量的解构赋值</h2>
<h3 id="数组的解构赋值">数组的解构赋值</h3>
<h4 id="基本用法">基本用法</h4>
<p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<p>ES6允许写成下面这样。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line">foo <span class="comment">// 1</span></div><div class="line">bar <span class="comment">// 2</span></div><div class="line">baz <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</div><div class="line">third <span class="comment">// "baz"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</div><div class="line">x <span class="comment">// "a"</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<p>如果解构不成功，变量的值就等于undefined。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [foo] = [];</div><div class="line"><span class="keyword">var</span> [bar, foo] = [<span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p>以上两种情况都属于解构不成功，foo的值都会等于undefined。</p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>上面两个例子，都属于不完全解构，但是可以成功。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> [foo] = {};</div></pre></td></tr></table></figure></p>
<p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p>
<p>解构赋值不仅适用于var命令，也适用于let和const命令。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [v1, v2, ..., vN ] = array;</div><div class="line"><span class="keyword">let</span> [v1, v2, ..., vN ] = array;</div><div class="line"><span class="keyword">const</span> [v1, v2, ..., vN ] = array;</div></pre></td></tr></table></figure></p>
<p>对于Set结构，也可以使用数组的解构赋值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> Set([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</div><div class="line">x <span class="comment">// "a"</span></div></pre></td></tr></table></figure></p>
<p>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</div><div class="line"><span class="keyword">yield</span> a;</div><div class="line">[a, b] = [b, a + b];</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</div><div class="line">sixth <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。</p>
<p>注意，ES6内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</div><div class="line">x <span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;</div><div class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) {</div><div class="line">x = f();</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">x = [<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></div><div class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p>
<p>上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。</p>
<h3 id="对象的解构赋值">对象的解构赋值</h3>
<p>解构不仅可以用于数组，还可以用于对象。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> { foo, bar } = { foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> };</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div></pre></td></tr></table></figure></p>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> { bar, foo } = { foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> };</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> { baz } = { foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> };</div><div class="line">baz <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> { foo: baz } = { foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> };</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = { first: <span class="string">'hello'</span>, last: <span class="string">'world'</span> };</div><div class="line"><span class="keyword">let</span> { first: f, last: l } = obj;</div><div class="line">f <span class="comment">// 'hello'</span></div><div class="line">l <span class="comment">// 'world'</span></div></pre></td></tr></table></figure></p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<p>这实际上说明，对象的解构赋值是下面形式的简写。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> { foo: foo, bar: bar } = { foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> };</div></pre></td></tr></table></figure></p>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> { foo: baz } = { foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> };</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line">foo <span class="comment">// error: foo is not defined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，真正被赋值的是变量baz，而不是模式foo。</p>
<p>注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> foo;</div><div class="line"><span class="keyword">let</span> {foo} = {foo: <span class="number">1</span>}; <span class="comment">// SyntaxError: Duplicate declaration "foo"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> baz;</div><div class="line"><span class="keyword">let</span> {bar: baz} = {bar: <span class="number">1</span>}; <span class="comment">// SyntaxError: Duplicate declaration "baz"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> foo;</div><div class="line">({foo} = {foo: <span class="number">1</span>}); <span class="comment">// 成功</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> baz;</div><div class="line">({bar: baz} = {bar: <span class="number">1</span>}); <span class="comment">// 成功</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</p>
<p>和数组一样，解构也可以用于嵌套结构的对象。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = {</div><div class="line">p: [</div><div class="line"><span class="string">'Hello'</span>,</div><div class="line">{ y: <span class="string">'World'</span> }</div><div class="line">]</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> { p: [x, { y }] } = obj;</div><div class="line">x <span class="comment">// "Hello"</span></div><div class="line">y <span class="comment">// "World"</span></div></pre></td></tr></table></figure></p>
<p>注意，这时p是模式，不是变量，因此不会被赋值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> node = {</div><div class="line">loc: {</div><div class="line">start: {</div><div class="line">line: <span class="number">1</span>,</div><div class="line">column: <span class="number">5</span></div><div class="line">}</div><div class="line">}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> { loc: { start: { line }} } = node;</div><div class="line">line <span class="comment">// 1</span></div><div class="line">loc  <span class="comment">// error: loc is undefined</span></div><div class="line">start <span class="comment">// error: start is undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，只有line是变量，loc和start都是模式，不会被赋值。</p>
<p>下面是嵌套赋值的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = {};</div><div class="line"><span class="keyword">let</span> arr = [];</div><div class="line"></div><div class="line">({ foo: obj.prop, bar: arr[<span class="number">0</span>] } = { foo: <span class="number">123</span>, bar: <span class="literal">true</span> });</div><div class="line"></div><div class="line">obj <span class="comment">// {prop:123}</span></div><div class="line">arr <span class="comment">// [true]</span></div></pre></td></tr></table></figure></p>
<p>对象的解构也可以指定默认值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> {x = <span class="number">3</span>} = {};</div><div class="line">x <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> {x, y = <span class="number">5</span>} = {x: <span class="number">1</span>};</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> {x:y = <span class="number">3</span>} = {};</div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> {x:y = <span class="number">3</span>} = {x: <span class="number">5</span>};</div><div class="line">y <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> { message: msg = <span class="string">'Something went wrong'</span> } = {};</div><div class="line">msg <span class="comment">// "Something went wrong"</span></div></pre></td></tr></table></figure></p>
<p>默认值生效的条件是，对象的属性值严格等于undefined。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> {x = <span class="number">3</span>} = {x: <span class="literal">undefined</span>};</div><div class="line">x <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> {x = <span class="number">3</span>} = {x: <span class="literal">null</span>};</div><div class="line">x <span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。</p>
<p>如果解构失败，变量的值等于undefined。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> {foo} = {bar: <span class="string">'baz'</span>};</div><div class="line">foo <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">var</span> {foo: {bar}} = {baz: <span class="string">'baz'</span>};</div></pre></td></tr></table></figure></p>
<p>上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _tmp = {baz: <span class="string">'baz'</span>};</div><div class="line">_tmp.foo.bar <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误的写法</span></div><div class="line"><span class="keyword">var</span> x;</div><div class="line">{x} = {x: <span class="number">1</span>};</div><div class="line"><span class="comment">// SyntaxError: syntax error</span></div></pre></td></tr></table></figure></p>
<p>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正确的写法</span></div><div class="line">({x} = {x: <span class="number">1</span>});</div></pre></td></tr></table></figure></p>
<p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见<a href="#%E5%9C%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98">下文</a>。</p>
<p>解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">({} = [<span class="literal">true</span>, <span class="literal">false</span>]);</div><div class="line">({} = <span class="string">'abc'</span>);</div><div class="line">({} = []);</div></pre></td></tr></table></figure></p>
<p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> { log, sin, cos } = <span class="built_in">Math</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p>
<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> {<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last} = arr;</div><div class="line">first <span class="comment">// 1</span></div><div class="line">last <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>上面代码对数组进行对象结构。数组arr的0键对应的值是1，<code>[arr.length - 1]</code> 就是2键，对应的值是3。</p>
<h3 id="字符串的解构赋值">字符串的解构赋值</h3>
<p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a <span class="comment">// "h"</span></div><div class="line">b <span class="comment">// "e"</span></div><div class="line">c <span class="comment">// "l"</span></div><div class="line">d <span class="comment">// "l"</span></div><div class="line">e <span class="comment">// "o"</span></div></pre></td></tr></table></figure></p>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> {length : len} = <span class="string">'hello'</span>;</div><div class="line">len <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h3 id="数值和布尔值的解构赋值">数值和布尔值的解构赋值</h3>
<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> {toString: s} = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> {toString: s} = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> { prop: x } = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">let</span> { prop: y } = <span class="literal">null</span>; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure></p>
<h3 id="函数参数的解构赋值">函数参数的解构赋值</h3>
<p>函数的参数也可以使用解构赋值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">([x, y])</span></span>{</div><div class="line"><span class="keyword">return</span> x + y;</div><div class="line">}</div><div class="line"></div><div class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<p>下面是另一个例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(([a, b]) =&gt; a + b);</div><div class="line"><span class="comment">// [ 3, 7 ]</span></div></pre></td></tr></table></figure></p>
<p>函数参数的解构也可以使用默认值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span><span class="params">({x = 0, y = 0} = {})</span> </span>{</div><div class="line"><span class="keyword">return</span> [x, y];</div><div class="line">}</div><div class="line"></div><div class="line">move({x: <span class="number">3</span>, y: <span class="number">8</span>}); <span class="comment">// [3, 8]</span></div><div class="line">move({x: <span class="number">3</span>}); <span class="comment">// [3, 0]</span></div><div class="line">move({}); <span class="comment">// [0, 0]</span></div><div class="line">move(); <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span><span class="params">({x, y} = { x: 0, y: 0 })</span> </span>{</div><div class="line"><span class="keyword">return</span> [x, y];</div><div class="line">}</div><div class="line"></div><div class="line">move({x: <span class="number">3</span>, y: <span class="number">8</span>}); <span class="comment">// [3, 8]</span></div><div class="line">move({x: <span class="number">3</span>}); <span class="comment">// [3, undefined]</span></div><div class="line">move({}); <span class="comment">// [undefined, undefined]</span></div><div class="line">move(); <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure></p>
<p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p>
<h3 id="圆括号问题">圆括号问题</h3>
<p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，<strong>建议只要有可能，就不要在模式中放置圆括号</strong>。</p>
<h4 id="不能使用圆括号的情况">不能使用圆括号的情况</h4>
<p>以下三种解构赋值不得使用圆括号。</p>
<p>（1）变量声明语句中，不能带有圆括号。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全部报错</span></div><div class="line"><span class="keyword">var</span> [(a)] = [<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> {x: (c)} = {};</div><div class="line"><span class="keyword">var</span> ({x: c}) = {};</div><div class="line"><span class="keyword">var</span> {(x: c)} = {};</div><div class="line"><span class="keyword">var</span> {(x): c} = {};</div><div class="line"></div><div class="line"><span class="keyword">var</span> { o: ({ p: p }) } = { o: { p: <span class="number">2</span> } };</div></pre></td></tr></table></figure></p>
<p>上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p>
<p>（2）函数参数中，模式不能带有圆括号。</p>
<p>函数参数也属于变量声明，因此不能带有圆括号。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">function f([(z)]) { return z; }</div></pre></td></tr></table></figure></p>
<p>（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全部报错</span></div><div class="line">({ p: a }) = { p: <span class="number">42</span> };</div><div class="line">([a]) = [<span class="number">5</span>];</div></pre></td></tr></table></figure></p>
<p>上面代码将整个模式放在圆括号之中，导致报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line">[({ p: a }), { x: c }] = [{}, {}];</div></pre></td></tr></table></figure></p>
<p>上面代码将嵌套模式的一层，放在圆括号之中，导致报错。</p>
<h4 id="可以使用圆括号的情况">可以使用圆括号的情况</h4>
<p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></div><div class="line">({ p: (d) } = {}); <span class="comment">// 正确</span></div><div class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></div></pre></td></tr></table></figure></p>
<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p>
<h3 id="用途">用途</h3>
<p>变量的解构赋值用途很多。</p>
<p>（1）交换变量的值</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure></p>
<p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p>（2）从函数返回多个值</p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个数组</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">}</div><div class="line"><span class="keyword">var</span> [a, b, c] = example();</div><div class="line"></div><div class="line"><span class="comment">// 返回一个对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">return</span> {</div><div class="line">foo: <span class="number">1</span>,</div><div class="line">bar: <span class="number">2</span></div><div class="line">};</div><div class="line">}</div><div class="line"><span class="keyword">var</span> { foo, bar } = example();</div></pre></td></tr></table></figure></p>
<p>（3）函数参数的定义</p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数是一组有次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x, y, z])</span> </span>{ ... }</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 参数是一组无次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">({x, y, z})</span> </span>{ ... }</div><div class="line">f({z: <span class="number">3</span>, y: <span class="number">2</span>, x: <span class="number">1</span>});</div></pre></td></tr></table></figure></p>
<p>（4）提取JSON数据</p>
<p>解构赋值对提取JSON对象中的数据，尤其有用。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonData = {</div><div class="line">id: <span class="number">42</span>,</div><div class="line">status: <span class="string">"OK"</span>,</div><div class="line">data: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">let</span> { id, status, data: number } = jsonData;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(id, status, number);</div><div class="line"><span class="comment">// 42, "OK", [867, 5309]</span></div></pre></td></tr></table></figure></p>
<p>上面代码可以快速提取JSON数据的值。</p>
<p>（5）函数参数的默认值</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = function (url, {</div><div class="line">async = true,</div><div class="line">beforeSend = function () {},</div><div class="line">cache = true,</div><div class="line">complete = function () {},</div><div class="line">crossDomain = false,</div><div class="line">global = true,</div><div class="line">// ... more config</div><div class="line">}) {</div><div class="line">// ... do stuff</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<p>（6）遍历Map结构</p>
<p>任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> Map();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] of map) {</div><div class="line"><span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">}</div><div class="line"><span class="comment">// first is hello</span></div><div class="line"><span class="comment">// second is world</span></div><div class="line">如果只想获取键名，或者只想获取键值，可以写成下面这样。</div><div class="line"></div><div class="line"><span class="comment">// 获取键名</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] of map) {</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 获取键值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] of map) {</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>（7）输入模块的指定方法</p>
<p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> { SourceMapConsumer, SourceNode } = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="语法扩展">语法扩展</h2>
<h3 id="字符串的扩展">字符串的扩展</h3>
<h4 id="字符的unicode表示法">字符的Unicode表示法</h4>
<h4 id="codepointat">codePointAt()</h4>
<h4 id="string-fromcodepoint">String.fromCodePoint()</h4>
<h4 id="字符串的遍历器接口">字符串的遍历器接口</h4>
<h4 id="at">at()</h4>
<h4 id="normalize">normalize()</h4>
<h4 id="includes-startswith-endswith">includes(), startsWith(), endsWith()</h4>
<h4 id="repeat">repeat()</h4>
<h4 id="padstart-padend">padStart()，padEnd()</h4>
<h4 id="模板字符串">模板字符串</h4>
<h4 id="标签模板">标签模板</h4>
<h4 id="string-raw">String.raw()</h4>
<h3 id="正则的扩展">正则的扩展</h3>
<h4 id="regexp构造函数">RegExp构造函数</h4>
<h3 id="字符串的正则方法">字符串的正则方法</h3>
<h3 id="u修饰符">u修饰符</h3>
<h3 id="y修饰符">y修饰符</h3>
<h3 id="sticky属性">sticky属性</h3>
<h3 id="flags属性">flags属性</h3>
<h3 id="regexp-escape">RegExp.escape()</h3>
<h3 id="后行断言">后行断言</h3>
<h3 id="数值的扩展">数值的扩展</h3>
<h4 id="二进制和八进制表示法">二进制和八进制表示法</h4>
<h4 id="number-isfinite-number-isnan">Number.isFinite(), Number.isNaN()</h4>
<h4 id="number-parseint-number-parsefloat">Number.parseInt(), Number.parseFloat()</h4>
<h4 id="number-isinteger">Number.isInteger()</h4>
<h4 id="number-epsilon">Number.EPSILON</h4>
<h4 id="安全整数和number-issafeinteger">安全整数和Number.isSafeInteger()</h4>
<h4 id="math对象的扩展">Math对象的扩展</h4>
<h4 id="指数运算符">指数运算符</h4>
<h3 id="数组的扩展">数组的扩展</h3>
<h3 id="函数的扩展">函数的扩展</h3>
<h4 id="默认值">默认值</h4>
<p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function log(x, y = 'World') {</div><div class="line">console.log(x, y);</div><div class="line">}</div><div class="line"></div><div class="line">log('Hello') // Hello World</div><div class="line">log('Hello', 'China') // Hello China</div><div class="line">log('Hello', '') // Hello</div></pre></td></tr></table></figure></p>
<h5 id="与解构赋值默认值结合使用">与解构赋值默认值结合使用</h5>
<p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">({x, y = 5})</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(x, y);</div><div class="line">}</div><div class="line"></div><div class="line">foo({}) <span class="comment">// undefined, 5</span></div><div class="line">foo({x: <span class="number">1</span>}) <span class="comment">// 1, 5</span></div><div class="line">foo({x: <span class="number">1</span>, y: <span class="number">2</span>}) <span class="comment">// 1, 2</span></div><div class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。如果参数对象没有y属性，y的默认值5才会生效。</p>
<h5 id="函数的length属性">函数的length属性</h5>
<p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a)</span> </span>{}).length <span class="comment">// 1</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a = 5)</span> </span>{}).length <span class="comment">// 0</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a, b, c = 5)</span> </span>{}).length <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了3个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。</p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，<a href="#rest%E5%8F%82%E6%95%B0">rest参数</a>也不会计入length属性。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">(...args)</span> </span>{}).length <span class="comment">// 0</span></div></pre></td></tr></table></figure></p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a = 0, b, c)</span> </span>{}).length <span class="comment">// 0</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a, b = 1, c)</span> </span>{}).length <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<h5 id="应用">应用</h5>
<p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function throwIfMissing() {</div><div class="line">throw new Error('Missing parameter');</div><div class="line">}</div><div class="line"></div><div class="line">function foo(mustBeProvided = throwIfMissing()) {</div><div class="line">return mustBeProvided;</div><div class="line">}</div><div class="line"></div><div class="line">foo()</div><div class="line">// Error: Missing parameter</div></pre></td></tr></table></figure></p>
<h5 id="rest-参数">rest 参数</h5>
<p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...values)</span> </span>{</div><div class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> val of values) {</div><div class="line">sum += val;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">}</div><div class="line"></div><div class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个rest参数代替arguments变量的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// arguments变量的写法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// rest参数的写法</span></div><div class="line"><span class="keyword">const</span> sortNumbers = (...numbers) =&gt; numbers.sort();</div></pre></td></tr></table></figure></p>
<p>上面代码的两种写法，比较后可以发现，rest参数的写法更自然也更简洁。</p>
<p>rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push方法的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(array, ...items)</span> </span>{</div><div class="line">items.forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>{</div><div class="line">array.push(item);</div><div class="line"><span class="built_in">console</span>.log(item);</div><div class="line">});</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [];</div><div class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a, ...b, c)</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line">函数的length属性，不包括rest参数。</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>{}).length  <span class="comment">// 1</span></div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">(...a)</span> </span>{}).length  <span class="comment">// 0</span></div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a, ...b)</span> </span>{}).length  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<h4 id="扩展运算符">扩展运算符</h4>
<h5 id="含义">含义</h5>
<p>扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="comment">// 1 2 3</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div><div class="line"></div><div class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</div><div class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></div></pre></td></tr></table></figure></p>
<p>该运算符主要用于函数调用。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(array, ...items)</span> </span>{</div><div class="line">array.push(...items);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> </span>{</div><div class="line"><span class="keyword">return</span> x + y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</div><div class="line">add(...numbers) <span class="comment">// 42</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(v, w, x, y, z)</span> </span>{ }</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</div><div class="line">f(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</div></pre></td></tr></table></figure></p>
<h4 id="name-属性">name 属性</h4>
<p>函数的name属性，返回该函数的函数名。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{}</div><div class="line">foo.name <span class="comment">// "foo"</span></div></pre></td></tr></table></figure></p>
<p>这个属性早就被浏览器广泛支持，但是直到ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5的name属性，会返回空字符串，而ES6的name属性会返回实际的函数名。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};</div><div class="line"></div><div class="line"><span class="comment">// ES5</span></div><div class="line">func1.name <span class="comment">// ""</span></div><div class="line"></div><div class="line"><span class="comment">// ES6</span></div><div class="line">func1.name <span class="comment">// "func1"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量func1等于一个匿名函数，ES5和ES6的name属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则ES5和ES6的name属性都返回这个具名函数原本的名字。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span><span class="params">()</span> </span>{};</div><div class="line"></div><div class="line"><span class="comment">// ES5</span></div><div class="line">bar.name <span class="comment">// "baz"</span></div><div class="line"></div><div class="line"><span class="comment">// ES6</span></div><div class="line">bar.name <span class="comment">// "baz"</span></div></pre></td></tr></table></figure></p>
<p>Function构造函数返回的函数实例，name属性的值为“anonymous”。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// "anonymous"</span></div></pre></td></tr></table></figure></p>
<p>bind返回的函数，name属性值会加上“bound ”前缀。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{};</div><div class="line">foo.bind({}).name <span class="comment">// "bound foo"</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{}).bind({}).name <span class="comment">// "bound "</span></div></pre></td></tr></table></figure></p>
<h4 id="箭头函数">箭头函数</h4>
<p>ES6允许使用“箭头”（=&gt;）定义函数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = v =&gt; v;</div></pre></td></tr></table></figure></p>
<p>上面的箭头函数等同于：</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span><span class="params">(v)</span> </span>{</div><div class="line"><span class="keyword">return</span> v;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = () =&gt; <span class="number">5</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="number">5</span> };</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = (num1, num2) =&gt; num1 + num2;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span> </span>{</div><div class="line"><span class="keyword">return</span> num1 + num2;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = (num1, num2) =&gt; { <span class="keyword">return</span> num1 + num2; }</div></pre></td></tr></table></figure></p>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getTempItem = id =&gt; ({ id: id, name: <span class="string">"Temp"</span> });</div></pre></td></tr></table></figure></p>
<p>箭头函数可以与变量解构结合使用。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> full = ({ first, last }) =&gt; first + <span class="string">' '</span> + last;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span><span class="params">(person)</span> </span>{</div><div class="line"><span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>箭头函数使得表达更加简洁。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isEven = n =&gt; n % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> square = n =&gt; n * n;</div></pre></td></tr></table></figure></p>
<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正常函数写法</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>{</div><div class="line"><span class="keyword">return</span> x * x;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// 箭头函数写法</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(x =&gt; x * x);</div></pre></td></tr></table></figure></p>
<p>另一个例子是</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正常函数写法</span></div><div class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> </span>{</div><div class="line"><span class="keyword">return</span> a - b;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// 箭头函数写法</span></div><div class="line"><span class="keyword">var</span> result = values.sort((a, b) =&gt; a - b);</div></pre></td></tr></table></figure></p>
<p>下面是rest参数与箭头函数结合的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = (...nums) =&gt; nums;</div><div class="line"></div><div class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line"><span class="comment">// [1,2,3,4,5]</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> headAndTail = (head, ...tail) =&gt; [head, tail];</div><div class="line"></div><div class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line"><span class="comment">// [1,[2,3,4,5]]</span></div></pre></td></tr></table></figure></p>
<h5 id="使用注意点">使用注意点</h5>
<p>箭头函数有几个使用注意点。</p>
<ol>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ol>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">setTimeout(() =&gt; {</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</div><div class="line">}, <span class="number">100</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</div><div class="line"></div><div class="line">foo.call({ id: <span class="number">42</span> });</div><div class="line"><span class="comment">// id: 42</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。</p>
<p>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">this</span>.s1 = <span class="number">0</span>;</div><div class="line"><span class="keyword">this</span>.s2 = <span class="number">0</span>;</div><div class="line"><span class="comment">// 箭头函数</span></div><div class="line">setInterval(() =&gt; <span class="keyword">this</span>.s1++, <span class="number">1000</span>);</div><div class="line"><span class="comment">// 普通函数</span></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="keyword">this</span>.s2++;</div><div class="line">}, <span class="number">1000</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</div><div class="line"></div><div class="line">setTimeout(() =&gt; <span class="built_in">console</span>.log(<span class="string">'s1: '</span>, timer.s1), <span class="number">3100</span>);</div><div class="line">setTimeout(() =&gt; <span class="built_in">console</span>.log(<span class="string">'s2: '</span>, timer.s2), <span class="number">3100</span>);</div><div class="line"><span class="comment">// s1: 3</span></div><div class="line"><span class="comment">// s2: 0</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。</p>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> handler = {</div><div class="line">id: <span class="string">'123456'</span>,</div><div class="line"></div><div class="line">init: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,</div><div class="line">event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</div><div class="line">},</div><div class="line"></div><div class="line">doSomething: <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Handling '</span> + type  + <span class="string">' for '</span> + <span class="keyword">this</span>.id);</div><div class="line">}</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成ES5的代码如下。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">setTimeout(() =&gt; {</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</div><div class="line">}, <span class="number">100</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</div><div class="line">}, <span class="number">100</span>);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</p>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">return</span> [</div><div class="line">(() =&gt; <span class="keyword">this</span>.x).bind({ x: <span class="string">'inner'</span> })()</div><div class="line">];</div><div class="line">}).call({ x: <span class="string">'outer'</span> });</div><div class="line"><span class="comment">// ['outer']</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。</p>
<p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。</p>
</div></p>
<h4 id="函数绑定">函数绑定</h4>
<p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>
<p>函数绑定运算符是并排的两个双冒号（<code>::</code>），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">foo::bar;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.bind(foo);</div><div class="line"></div><div class="line">foo::bar(...arguments);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.apply(foo, <span class="built_in">arguments</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasOwn</span><span class="params">(obj, key)</span> </span>{</div><div class="line"><span class="keyword">return</span> obj::hasOwnProperty(key);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> method = obj::obj.foo;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> method = ::obj.foo;</div><div class="line"></div><div class="line"><span class="keyword">let</span> log = ::<span class="built_in">console</span>.log;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</div></pre></td></tr></table></figure></p>
<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例一</span></div><div class="line">import { map, takeWhile, forEach } from <span class="string">"iterlib"</span>;</div><div class="line"></div><div class="line">getPlayers()</div><div class="line">::map(x =&gt; x.character())</div><div class="line">::takeWhile(x =&gt; x.strength &gt; <span class="number">100</span>)</div><div class="line">::forEach(x =&gt; <span class="built_in">console</span>.log(x));</div><div class="line"></div><div class="line"><span class="comment">// 例二</span></div><div class="line"><span class="keyword">let</span> { find, html } = jake;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">"div.myClass"</span>)</div><div class="line">::find(<span class="string">"p"</span>)</div><div class="line">::html(<span class="string">"hahaha"</span>);</div></pre></td></tr></table></figure></p>
<h4 id="尾调用优化">尾调用优化</h4>
<h4 id="函数参数的尾逗号">函数参数的尾逗号</h4>
<h3 id="对象的扩展">对象的扩展</h3>
<h3 id="symbol">Symbol</h3>
<h3 id="proxy-和-reflect">Proxy 和 Reflect</h3>
<h3 id="二进制数组">二进制数组</h3>
<h3 id="set-和-map-的数据结构">Set 和 Map 的数据结构</h3>
<h3 id="iterator-和-for-of-循环">Iterator 和 for…of 循环</h3>
<h2 id="promise-对象">Promise 对象</h2>
<h3 id="含义-v2">含义</h3>
<p>Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<ol>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。</p>
<h3 id="基本用法-v2">基本用法</h3>
<p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<p>下面代码创造了一个Promise实例。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>{</div><div class="line"><span class="comment">// ... some code</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>){</div><div class="line">resolve(value);</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">reject(error);</div><div class="line">}</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>{</div><div class="line"><span class="comment">// success</span></div><div class="line">}, <span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>{</div><div class="line"><span class="comment">// failure</span></div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<p>下面是一个Promise对象的简单例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span><span class="params">(ms)</span> </span>{</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {</div><div class="line">setTimeout(resolve, ms, <span class="string">'done'</span>);</div><div class="line">});</div><div class="line">}</div><div class="line"></div><div class="line">timeout(<span class="number">100</span>).then((value) =&gt; {</div><div class="line"><span class="built_in">console</span>.log(value);</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。</p>
<p>Promise新建后就会立即执行。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</div><div class="line">resolve();</div><div class="line">});</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Resolved.'</span>);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Promise</span></div><div class="line"><span class="comment">// Hi!</span></div><div class="line"><span class="comment">// Resolved</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，Promise新建后立即执行，所以首先输出的是“Promise”。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以“Resolved”最后输出。</p>
<p>下面是异步加载图片的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span><span class="params">(url)</span> </span>{</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>{</div><div class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image();</div><div class="line"></div><div class="line">image.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">resolve(image);</div><div class="line">};</div><div class="line"></div><div class="line">image.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + url));</div><div class="line">};</div><div class="line"></div><div class="line">image.src = url;</div><div class="line">});</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。</p>
<p>下面是一个用Promise对象实现的Ajax操作的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span><span class="params">(url)</span> </span>{</div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span></span>{</div><div class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">client.open(<span class="string">"GET"</span>, url);</div><div class="line">client.onreadystatechange = handler;</div><div class="line">client.responseType = <span class="string">"json"</span>;</div><div class="line">client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</div><div class="line">client.send();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) {</div><div class="line"><span class="keyword">return</span>;</div><div class="line">}</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) {</div><div class="line">resolve(<span class="keyword">this</span>.response);</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</div><div class="line">}</div><div class="line">};</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">return</span> promise;</div><div class="line">};</div><div class="line"></div><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(json)</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</div><div class="line">}, <span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>{</div><div class="line"><span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>上面代码中，getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">resolve(p1);</div><div class="line">})</div></pre></td></tr></table></figure></p>
<p>上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>{</div><div class="line">setTimeout(() =&gt; reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</div><div class="line">})</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>{</div><div class="line">setTimeout(() =&gt; resolve(p1), <span class="number">1000</span>)</div><div class="line">})</div><div class="line"></div><div class="line">p2</div><div class="line">.then(result =&gt; <span class="built_in">console</span>.log(result))</div><div class="line">.catch(error =&gt; <span class="built_in">console</span>.log(error))</div><div class="line"><span class="comment">// Error: fail</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<h4 id="promise-prototype-then">Promise.prototype.then()</h4>
<p>Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(json)</span> </span>{</div><div class="line"><span class="keyword">return</span> json.post;</div><div class="line">}).then(<span class="function"><span class="keyword">function</span><span class="params">(post)</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(post)</span> </span>{</div><div class="line"><span class="keyword">return</span> getJSON(post.commentURL);</div><div class="line">}).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span><span class="params">(comments)</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Resolved: "</span>, comments);</div><div class="line">}, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span><span class="params">(err)</span></span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Rejected: "</span>, err);</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getjson(<span class="string">"/post/1.json"</span>).then(</div><div class="line">post =&gt; getjson(post.commenturl)</div><div class="line">).then(</div><div class="line">comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</div><div class="line">err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="promise-prototype-catch">Promise.prototype.catch()</h4>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.catch方法是.then(<span class="literal">null</span>, rejection)的别名，用于指定发生错误时的回调函数。</div><div class="line"></div><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(posts)</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">}).catch(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>{</div><div class="line"><span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<p>一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">promise</div><div class="line">.then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{</div><div class="line"><span class="comment">// success</span></div><div class="line">}, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line"><span class="comment">// error</span></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">promise</div><div class="line">.then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{ <span class="comment">//cb</span></div><div class="line"><span class="comment">// success</span></div><div class="line">})</div><div class="line">.catch(<span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line"><span class="comment">// error</span></div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。</p>
<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<p>catch方法之中，还能再抛出错误，通过下一个 catch 捕获。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">return</span> someOtherAsyncThing();</div><div class="line">}).catch(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</div><div class="line"><span class="comment">// 下面一行会报错，因为y没有声明</span></div><div class="line">y + <span class="number">2</span>;</div><div class="line">}).catch(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'carry on'</span>, error);</div><div class="line">});</div><div class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></div><div class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></div></pre></td></tr></table></figure></p>
<h4 id="promise-all">Promise.all()</h4>
<p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = Promise.all([p1, p2, p3]);</div></pre></td></tr></table></figure></p>
<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<ol>
<li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ol>
<p>下面是一个具体的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> databasePromise = connectDatabase();</div><div class="line"></div><div class="line"><span class="keyword">const</span> booksPromise = databaseProimse</div><div class="line">.then(findAllBooks);</div><div class="line"></div><div class="line"><span class="keyword">const</span> userPromise = databasePromise</div><div class="line">.then(getCurrentUser);</div><div class="line"></div><div class="line">Promise.all([</div><div class="line">booksPromise,</div><div class="line">userPromise</div><div class="line">])</div><div class="line">.then(([books, user]) =&gt; pickTopRecommentations(books, user));</div></pre></td></tr></table></figure></p>
<p>上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。</p>
<h4 id="promise-race">Promise.race()</h4>
<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = Promise.race([p1,p2,p3]);</div></pre></td></tr></table></figure></p>
<p>上面代码中，只要p1、p2、p3之中<strong>有一个实例率先改变状态，p的状态就跟着改变</strong>。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>
<p>Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = Promise.race([</div><div class="line">fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</div><div class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>{</div><div class="line">setTimeout(() =&gt; reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</div><div class="line">})</div><div class="line">])</div><div class="line">p.then(response =&gt; <span class="built_in">console</span>.log(response))</div><div class="line">p.catch(error =&gt; <span class="built_in">console</span>.log(error))</div></pre></td></tr></table></figure></p>
<p>上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p>
<h4 id="promise-resolve">Promise.resolve()</h4>
<p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsPromise = Promise.resolve($.ajax(<span class="string">'/whatever.json'</span>));</div></pre></td></tr></table></figure></p>
<p>上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。</p>
<p>Promise.resolve等价于下面的写法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Promise.resolve(<span class="string">'foo'</span>)</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">new</span> Promise(resolve =&gt; resolve(<span class="string">'foo'</span>))</div><div class="line">Promise.resolve方法的参数分成四种情况。</div></pre></td></tr></table></figure></p>
<p>（1）参数是一个Promise实例</p>
<p>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p>
<p>（2）参数是一个thenable对象</p>
<p>thenable对象指的是具有then方法的对象，比如下面这个对象。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = {</div><div class="line">then: <span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>{</div><div class="line">resolve(<span class="number">42</span>);</div><div class="line">}</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = {</div><div class="line">then: <span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>{</div><div class="line">resolve(<span class="number">42</span>);</div><div class="line">}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = Promise.resolve(thenable);</div><div class="line">p1.then(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。</p>
<p>（3）参数不是具有then方法的对象，或根本就不是对象</p>
<p>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = Promise.resolve(<span class="string">'Hello'</span>);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="params">(s)</span></span>{</div><div class="line"><span class="built_in">console</span>.log(s)</div><div class="line">});</div><div class="line"><span class="comment">// Hello</span></div></pre></td></tr></table></figure></p>
<p>上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p>
<p>（4）不带有任何参数</p>
<p>Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。</p>
<p>所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = Promise.resolve();</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>上面代码的变量p就是一个Promise对象。</p>
<p>需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'three'</span>);</div><div class="line">}, <span class="number">0</span>);</div><div class="line"></div><div class="line">Promise.resolve().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'two'</span>);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</div><div class="line"></div><div class="line"><span class="comment">// one</span></div><div class="line"><span class="comment">// two</span></div><div class="line"><span class="comment">// three</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。</p>
<h4 id="promise-reject">Promise.reject()</h4>
<p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = Promise.reject(<span class="string">'出错了'</span>);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Promise((resolve, reject) =&gt; reject(<span class="string">'出错了'</span>))</div><div class="line"></div><div class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">(s)</span></span>{</div><div class="line"><span class="built_in">console</span>.log(s)</div><div class="line">});</div><div class="line"><span class="comment">// 出错了</span></div></pre></td></tr></table></figure></p>
<p>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p>
<h4 id="两个有用的附加方法">两个有用的附加方法</h4>
<p>下面介绍如何部署两个不在ES6之中、但很有用的方法。</p>
<h5 id="done">done()</h5>
<p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunc()</div><div class="line">.then(f1)</div><div class="line">.catch(r1)</div><div class="line">.then(f2)</div><div class="line">.done();</div></pre></td></tr></table></figure></p>
<p>它的实现代码相当简单。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.done = <span class="function"><span class="keyword">function</span> <span class="params">(onFulfilled, onRejected)</span> </span>{</div><div class="line"><span class="keyword">this</span>.then(onFulfilled, onRejected)</div><div class="line">.catch(<span class="function"><span class="keyword">function</span> <span class="params">(reason)</span> </span>{</div><div class="line"><span class="comment">// 抛出一个全局错误</span></div><div class="line">setTimeout(() =&gt; { <span class="keyword">throw</span> reason }, <span class="number">0</span>);</div><div class="line">});</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。</p>
<h5 id="finally">finally()</h5>
<p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<p>下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.listen(<span class="number">0</span>)</div><div class="line">.then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="comment">// run test</span></div><div class="line">})</div><div class="line">.finally(server.stop);</div></pre></td></tr></table></figure></p>
<p>它的实现也很简单。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.finally = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> </span>{</div><div class="line"><span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.then(</div><div class="line">value  =&gt; P.resolve(callback()).then(() =&gt; value),</div><div class="line">reason =&gt; P.resolve(callback()).then(() =&gt; { <span class="keyword">throw</span> reason })</div><div class="line">);</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。</p>
<h2 id="generator-函数">Generator 函数</h2>
<h3 id="协程">协程</h3>
<p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做&quot;协程&quot;（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<ol>
<li>第一步，协程A开始执行。</li>
<li>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</li>
<li>第三步，（一段时间后）协程B交还执行权。</li>
<li>第四步，协程A恢复执行。</li>
</ol>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">asyncJob</span><span class="params">()</span> </span>{</div><div class="line"><span class="comment">// ...其他代码</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</div><div class="line"><span class="comment">// ...其他代码</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。</p>
<p>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h4 id="generator函数的概念">Generator函数的概念</h4>
<p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">(x)</span></span>{</div><div class="line"><span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</div><div class="line"><span class="keyword">return</span> y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</div><div class="line">g.next() <span class="comment">// { value: 3, done: false }</span></div><div class="line">g.next() <span class="comment">// { value: undefined, done: true }</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。</p>
<p>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<h4 id="generator函数的数据交换和错误处理">Generator函数的数据交换和错误处理</h4>
<p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p>next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。</p>
<p>上面代码中，第一个next方法的value属性，返回表达式x + 2的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。</p>
<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">(x)</span></span>{</div><div class="line"><span class="keyword">try</span> {</div><div class="line"><span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</div><div class="line">} <span class="keyword">catch</span> (e){</div><div class="line"><span class="built_in">console</span>.log(e);</div><div class="line">}</div><div class="line"><span class="keyword">return</span> y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</div><div class="line">g.next();</div><div class="line">g.throw(<span class="string">'出错了'</span>);</div><div class="line"><span class="comment">// 出错了</span></div></pre></td></tr></table></figure></p>
<p>上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try …catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h4 id="异步任务的封装">异步任务的封装</h4>
<p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span></span>{</div><div class="line"><span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</div><div class="line"><span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</div><div class="line"><span class="built_in">console</span>.log(result.bio);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p>
<p>执行这段代码的方法如下。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line"><span class="keyword">var</span> result = g.next();</div><div class="line"></div><div class="line">result.value.then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{</div><div class="line"><span class="keyword">return</span> data.json();</div><div class="line">}).then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{</div><div class="line">g.next(data);</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个Promise对象，因此要用 then 方法调用下一个 next 方法。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h4 id="thunk-函数">Thunk 函数</h4>
<p>Thunk 函数主要用于实现编译器的&quot;传名调用&quot;（call by name）。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(m)</span></span>{</div><div class="line"><span class="keyword">return</span> m * <span class="number">2</span>;</div><div class="line">}</div><div class="line"></div><div class="line">f(x + <span class="number">5</span>)</div></pre></td></tr></table></figure></p>
<p>上面代码先定义函数f，然后向它传入表达式x + 5。请问，这个表达式应该何时求值？</p>
<ul>
<li>一种意见是&quot;传值调用&quot;（call by value），即在进入函数体之前，就计算x + 5的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</li>
<li>另一种意见是&quot;传名调用&quot;（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</li>
</ul>
<p>编译器的&quot;传名调用&quot;实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(m)</span></span>{</div><div class="line"><span class="keyword">return</span> m * <span class="number">2</span>;</div><div class="line">}</div><div class="line"></div><div class="line">f(x + <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="keyword">return</span> x + <span class="number">5</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(thunk)</span></span>{</div><div class="line"><span class="keyword">return</span> thunk() * <span class="number">2</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></div><div class="line">fs.readFile(fileName, callback);</div><div class="line"></div><div class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></div><div class="line"><span class="keyword">var</span> readFileThunk = Thunk(fileName);</div><div class="line">readFileThunk(callback);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> <span class="params">(fileName)</span></span>{</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span></span>{</div><div class="line"><span class="keyword">return</span> fs.readFile(fileName, callback);</div><div class="line">};</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>使用上面的转换器，生成fs.readFile的Thunk函数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</div><div class="line">readFileThunk(fileA)(callback);</div></pre></td></tr></table></figure></p>
<p>下面是另一个完整的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a, cb)</span> </span>{</div><div class="line">cb(a);</div><div class="line">}</div><div class="line"><span class="keyword">let</span> ft = Thunk(f);</div><div class="line"></div><div class="line"><span class="keyword">let</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</div><div class="line">ft(<span class="number">1</span>)(log) <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<h5 id="thunkify模块">Thunkify模块</h5>
<p>生产环境的转换器，建议使用Thunkify模块。</p>
<p>首先是安装。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install thunkify</div></pre></td></tr></table></figure></p>
<p>使用方式如下。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</div><div class="line">read(<span class="string">'package.json'</span>)(<span class="function"><span class="keyword">function</span><span class="params">(err, str)</span></span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>Thunkify的源码与上一节那个简单的转换器非常像。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span><span class="params">(fn)</span></span>{</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line"><span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</div><div class="line"><span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) {</div><div class="line">args[i] = <span class="built_in">arguments</span>[i];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(done)</span></span>{</div><div class="line"><span class="keyword">var</span> called;</div><div class="line"></div><div class="line">args.push(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line"><span class="keyword">if</span> (called) <span class="keyword">return</span>;</div><div class="line">called = <span class="literal">true</span>;</div><div class="line">done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">try</span> {</div><div class="line">fn.apply(ctx, args);</div><div class="line">} <span class="keyword">catch</span> (err) {</div><div class="line">done(err);</div><div class="line">}</div><div class="line">}</div><div class="line">}</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a, b, callback)</span></span>{</div><div class="line"><span class="keyword">var</span> sum = a + b;</div><div class="line">callback(sum);</div><div class="line">callback(sum);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> ft = thunkify(f);</div><div class="line"><span class="keyword">var</span> print = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</div><div class="line">ft(<span class="number">1</span>, <span class="number">2</span>)(print);</div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。</p>
<h4 id="generator-函数的流程管理">Generator 函数的流程管理</h4>
<p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(fn)</span> </span>{</div><div class="line"><span class="keyword">var</span> gen = fn();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err, data)</span> </span>{</div><div class="line"><span class="keyword">var</span> result = gen.next(data);</div><div class="line"><span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</div><div class="line">result.value(next);</div><div class="line">}</div><div class="line"></div><div class="line">next();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span><span class="params">()</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line">run(g);</div></pre></td></tr></table></figure></p>
<p>上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。</p>
<p>有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* <span class="params">()</span></span>{</div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'fileA'</span>);</div><div class="line"><span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'fileB'</span>);</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">var</span> fn = <span class="keyword">yield</span> readFile(<span class="string">'fileN'</span>);</div><div class="line">};</div><div class="line"></div><div class="line">run(g);</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
<h2 id="异步操作和-async-函数">异步操作和 Async 函数</h2>
<p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<p>ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。</p>
<h3 id="co-模块">co 模块</h3>
<p><a href="https://github.com/tj/co" target="_blank" rel="external">co模块</a> 是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。</p>
<p>比如，有一个Generator函数，用于依次读取两个文件。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="params">()</span></span>{</div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</div><div class="line"><span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</div><div class="line"><span class="built_in">console</span>.log(f1.toString());</div><div class="line"><span class="built_in">console</span>.log(f2.toString());</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>co模块可以让你不用编写Generator函数的执行器。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line">co(gen);</div></pre></td></tr></table></figure></p>
<p>上面代码中，Generator函数只要传入co函数，就会自动执行。</p>
<p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">co(gen).then(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>);</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p>
<h4 id="co模块的原理">co模块的原理</h4>
<p>为什么co可以自动执行Generator函数？</p>
<p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<ol>
<li>回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</li>
<li>Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。</li>
</ol>
<p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p>
<p>上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p>
<h5 id="基于promise对象的自动执行">基于Promise对象的自动执行</h5>
<p>还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> <span class="params">(fileName)</span></span>{</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span></span>{</div><div class="line">fs.readFile(fileName, <span class="function"><span class="keyword">function</span><span class="params">(error, data)</span></span>{</div><div class="line"><span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</div><div class="line">resolve(data);</div><div class="line">});</div><div class="line">});</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="params">()</span></span>{</div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</div><div class="line"><span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</div><div class="line"><span class="built_in">console</span>.log(f1.toString());</div><div class="line"><span class="built_in">console</span>.log(f2.toString());</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>然后，手动执行上面的Generator函数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line"></div><div class="line">g.next().value.then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{</div><div class="line">g.next(data).value.then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{</div><div class="line">g.next(data);</div><div class="line">});</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(gen)</span></span>{</div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(data)</span></span>{</div><div class="line"><span class="keyword">var</span> result = g.next(data);</div><div class="line"><span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</div><div class="line">result.value.then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{</div><div class="line">next(data);</div><div class="line">});</div><div class="line">}</div><div class="line"></div><div class="line">next();</div><div class="line">}</div><div class="line"></div><div class="line">run(gen);</div></pre></td></tr></table></figure></p>
<p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p>
<h4 id="处理并发的异步操作">处理并发的异步操作</h4>
<p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p>这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组的写法</span></div><div class="line">co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>{</div><div class="line"><span class="keyword">var</span> res = <span class="keyword">yield</span> [</div><div class="line">Promise.resolve(<span class="number">1</span>),</div><div class="line">Promise.resolve(<span class="number">2</span>)</div><div class="line">];</div><div class="line"><span class="built_in">console</span>.log(res);</div><div class="line">}).catch(onerror);</div><div class="line"></div><div class="line"><span class="comment">// 对象的写法</span></div><div class="line">co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>{</div><div class="line"><span class="keyword">var</span> res = <span class="keyword">yield</span> {</div><div class="line"><span class="number">1</span>: Promise.resolve(<span class="number">1</span>),</div><div class="line"><span class="number">2</span>: Promise.resolve(<span class="number">2</span>),</div><div class="line">};</div><div class="line"><span class="built_in">console</span>.log(res);</div><div class="line">}).catch(onerror);</div></pre></td></tr></table></figure></p>
<p>下面是另一个例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>{</div><div class="line"><span class="keyword">var</span> values = [n1, n2, n3];</div><div class="line"><span class="keyword">yield</span> values.map(somethingAsync);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">somethingAsync</span><span class="params">(x)</span> </span>{</div><div class="line"><span class="comment">// do something async</span></div><div class="line"><span class="keyword">return</span> y</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。</p>
<h3 id="async-函数">async 函数</h3>
<h4 id="含义-v3">含义</h4>
<p>ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话，async函数就是Generator函数的语法糖。</p>
<p>前文有一个Generator函数，依次读取两个文件。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> <span class="params">(fileName)</span> </span>{</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>{</div><div class="line">fs.readFile(fileName, <span class="function"><span class="keyword">function</span><span class="params">(error, data)</span> </span>{</div><div class="line"><span class="keyword">if</span> (error) reject(error);</div><div class="line">resolve(data);</div><div class="line">});</div><div class="line">});</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="params">()</span></span>{</div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</div><div class="line"><span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</div><div class="line"><span class="built_in">console</span>.log(f1.toString());</div><div class="line"><span class="built_in">console</span>.log(f2.toString());</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>写成async函数，就是下面这样。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> asyncReadFile = async <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{</div><div class="line"><span class="keyword">var</span> f1 = await readFile(<span class="string">'/etc/fstab'</span>);</div><div class="line"><span class="keyword">var</span> f2 = await readFile(<span class="string">'/etc/shells'</span>);</div><div class="line"><span class="built_in">console</span>.log(f1.toString());</div><div class="line"><span class="built_in">console</span>.log(f2.toString());</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async函数对 Generator 函数的改进，体现在以下四点。</p>
<p>（1）内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = asyncReadFile();</div></pre></td></tr></table></figure></p>
<p>上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用next方法，或者用co模块，才能得到真正执行，得到最后结果。</p>
<p>（2）更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<p>（4）返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。</p>
<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。</p>
<p>async函数的语法规则总体上比较简单，难点是错误处理机制。</p>
<p>（1）async函数返回一个Promise对象。</p>
<p>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">return</span> <span class="string">'hello world'</span>;</div><div class="line">}</div><div class="line"></div><div class="line">f().then(v =&gt; <span class="built_in">console</span>.log(v))</div><div class="line"><span class="comment">// "hello world"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。</p>
<p>async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</div><div class="line">}</div><div class="line"></div><div class="line">f().then(</div><div class="line">v =&gt; <span class="built_in">console</span>.log(v),</div><div class="line">e =&gt; <span class="built_in">console</span>.log(e)</div><div class="line">)</div><div class="line"><span class="comment">// Error: 出错了</span></div></pre></td></tr></table></figure></p>
<p>（2）async函数返回的Promise对象，必须等到内部所有await命令的Promise对象执行完，才会发生状态改变。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p>
<p>下面是一个例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span><span class="params">(url)</span> </span>{</div><div class="line"><span class="keyword">let</span> response = await fetch(url);</div><div class="line"><span class="keyword">let</span> html = await response.text();</div><div class="line"><span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</div><div class="line">}</div><div class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span>.log)</div><div class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></div></pre></td></tr></table></figure></p>
<p>（3）正常情况下，await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">return</span> await <span class="number">123</span>;</div><div class="line">}</div><div class="line"></div><div class="line">f().then(v =&gt; <span class="built_in">console</span>.log(v))</div><div class="line"><span class="comment">// 123</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，await命令的参数是数值123，它被转成Promise对象，并立即resolve。</p>
<p>await命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line">await Promise.reject(<span class="string">'出错了'</span>);</div><div class="line">}</div><div class="line"></div><div class="line">f()</div><div class="line">.then(v =&gt; <span class="built_in">console</span>.log(v))</div><div class="line">.catch(e =&gt; <span class="built_in">console</span>.log(e))</div><div class="line"><span class="comment">// 出错了</span></div></pre></td></tr></table></figure></p>
<p>注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。</p>
<p>只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line">await Promise.reject(<span class="string">'出错了'</span>);</div><div class="line">await Promise.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。</p>
<p>为了避免这个问题，可以将第一个await放在try…catch结构里面，这样第二个await就会执行。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">try</span> {</div><div class="line">await Promise.reject(<span class="string">'出错了'</span>);</div><div class="line">} <span class="keyword">catch</span>(e) {</div><div class="line">}</div><div class="line"><span class="keyword">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</div><div class="line">}</div><div class="line"></div><div class="line">f()</div><div class="line">.then(v =&gt; <span class="built_in">console</span>.log(v))</div><div class="line"><span class="comment">// hello world</span></div></pre></td></tr></table></figure></p>
<p>另一种方法是await后面的Promise对象再跟一个catch方面，处理前面可能出现的错误。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line">await Promise.reject(<span class="string">'出错了'</span>)</div><div class="line">.catch(e =&gt; <span class="built_in">console</span>.log(e));</div><div class="line"><span class="keyword">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</div><div class="line">}</div><div class="line"></div><div class="line">f()</div><div class="line">.then(v =&gt; <span class="built_in">console</span>.log(v))</div><div class="line"><span class="comment">// 出错了</span></div><div class="line"><span class="comment">// hello world</span></div></pre></td></tr></table></figure></p>
<p>如果有多个await命令，可以统一放在try…catch结构中。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">try</span> {</div><div class="line"><span class="keyword">var</span> val1 = await firstStep();</div><div class="line"><span class="keyword">var</span> val2 = await secondStep(val1);</div><div class="line"><span class="keyword">var</span> val3 = await thirdStep(val1, val2);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Final: '</span>, val3);</div><div class="line">}</div><div class="line"><span class="keyword">catch</span> (err) {</div><div class="line"><span class="built_in">console</span>.error(err);</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>（4）如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line">await <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>{</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</div><div class="line">});</div><div class="line">}</div><div class="line"></div><div class="line">f()</div><div class="line">.then(v =&gt; <span class="built_in">console</span>.log(v))</div><div class="line">.catch(e =&gt; <span class="built_in">console</span>.log(e))</div><div class="line"><span class="comment">// Error：出错了</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，async函数f执行后，await后面的Promise对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async函数的实现”。</p>
<p>防止出错的方法，也是将其放在try…catch代码块之中。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>{</div><div class="line"><span class="keyword">try</span> {</div><div class="line">await <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>{</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</div><div class="line">});</div><div class="line">} <span class="keyword">catch</span>(e) {</div><div class="line">}</div><div class="line"><span class="keyword">return</span> await(<span class="string">'hello world'</span>);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p><div class="alert alert-warning"><i class="fa fa-bell"></i>  <p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在 <code>try...catch</code> 代码块中。</p>
</div></p>
<h2 id="class">Class</h2>
<h3 id="基本语法">基本语法</h3>
<p>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x, y)</span> </span>{</div><div class="line"><span class="keyword">this</span>.x = x;</div><div class="line"><span class="keyword">this</span>.y = y;</div><div class="line">}</div><div class="line"></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="keyword">class</span> Point {</div><div class="line">constructor(x, y) {</div><div class="line"><span class="keyword">this</span>.x = x;</div><div class="line"><span class="keyword">this</span>.y = y;</div><div class="line">}</div><div class="line"></div><div class="line">toString() {</div><div class="line"><span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。</p>
<p>Point类除了构造方法，还定义了一个toString方法。注意，<strong>定义“类”的方法的时候，前面不需要加上function这个关键字</strong>，直接把函数定义放进去了就可以了。另外，<strong>方法之间不需要逗号分隔，加了会报错</strong>。</p>
<p><div class="alert alert-warning"><i class="fa fa-bell"></i>  <ul>
<li>类方法的定义前面不需要加 <code>function</code> 关键字；</li>
<li>方法之间不需要逗号分隔。</li>
</ul>
</div></p>
<p>ES6的类，完全可以看作构造函数的另一种写法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Point {</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></div><div class="line">Point === Point.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Bar {</div><div class="line">doStuff() {</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'stuff'</span>);</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Bar();</div><div class="line">b.doStuff() <span class="comment">// "stuff"</span></div></pre></td></tr></table></figure></p>
<p>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Point {</div><div class="line">constructor(){</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line">toString(){</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line">toValue(){</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line">Point.prototype = {</div><div class="line">toString(){},</div><div class="line">toValue(){}</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> B {}</div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div><div class="line"></div><div class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Point {</div><div class="line">constructor(){</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(Point.prototype, {</div><div class="line">toString(){},</div><div class="line">toValue(){}</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point.prototype.constructor === Point <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>另外，类的内部所有定义的方法，都是<strong>不可枚举的（non-enumerable）</strong>。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Point {</div><div class="line">constructor(x, y) {</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line">toString() {</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.keys(Point.prototype)</div><div class="line"><span class="comment">// []</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</div><div class="line"><span class="comment">// ["constructor","toString"]</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Point = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.keys(Point.prototype)</div><div class="line"><span class="comment">// ["toString"]</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</div><div class="line"><span class="comment">// ["constructor","toString"]</span></div></pre></td></tr></table></figure></p>
<p>上面代码采用ES5的写法，toString方法就是可枚举的。</p>
<p>类的属性名，可以采用表达式。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> methodName = <span class="string">"getArea"</span>;</div><div class="line"><span class="keyword">class</span> Square{</div><div class="line">constructor(length) {</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line">[methodName]() {</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中，Square类的方法名getArea，是从表达式得到的。</p>
<h4 id="不存在变量提升-v2">不存在变量提升</h4>
<p>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">class</span> Foo {}</div></pre></td></tr></table></figure></p>
<p>上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line"><span class="keyword">let</span> Foo = <span class="keyword">class</span> {};</div><div class="line"><span class="keyword">class</span> Bar extends Foo {</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面的代码不会报错，因为class继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致class继承Foo的时候，Foo还没有定义。</p>
<h4 id="class-表达式">Class 表达式</h4>
<p>与函数一样，类也可以使用表达式的形式定义。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyClass = <span class="keyword">class</span> Me {</div><div class="line">getClassName() {</div><div class="line"><span class="keyword">return</span> Me.name;</div><div class="line">}</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，<strong>Me只在Class的内部代码可用，指代当前类</strong>。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</div><div class="line">inst.getClassName() <span class="comment">// Me</span></div><div class="line">Me.name <span class="comment">// ReferenceError: Me is not defined</span></div></pre></td></tr></table></figure></p>
<p>上面代码表示，Me只在Class内部有定义。</p>
<p>如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyClass = <span class="keyword">class</span> { <span class="comment">/* ... */</span> };</div></pre></td></tr></table></figure></p>
<p>采用Class表达式，可以写出立即执行的Class。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="keyword">class</span> {</div><div class="line">constructor(name) {</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">}</div><div class="line"></div><div class="line">sayName() {</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">}</div><div class="line">}(<span class="string">'张三'</span>);</div><div class="line"></div><div class="line">person.sayName(); <span class="comment">// "张三"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，person是一个立即执行的类的实例。</p>
<h4 id="私有方法">私有方法</h4>
<p>私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。</p>
<ul>
<li>一种做法是在<a href="/wiki/javascript-es3.html#%E5%BB%BA%E8%AE%AE%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">命名上加以区别</a>。</li>
<li>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</li>
</ul>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget {</div><div class="line">foo (baz) {</div><div class="line">bar.call(<span class="keyword">this</span>, baz);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(baz)</span> </span>{</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<ul>
<li>还有一种方法是利用<a href="#symbol">Symbol值</a>的唯一性，将私有方法的名字命名为一个Symbol值。</li>
</ul>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bar = Symbol(<span class="string">'bar'</span>);</div><div class="line"><span class="keyword">const</span> snaf = Symbol(<span class="string">'snaf'</span>);</div><div class="line"></div><div class="line">export <span class="keyword">default</span> <span class="keyword">class</span> myClass{</div><div class="line"></div><div class="line"><span class="comment">// 公有方法</span></div><div class="line">foo(baz) {</div><div class="line"><span class="keyword">this</span>[bar](baz);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 私有方法</span></div><div class="line">[bar](baz) {</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>[snaf] = baz;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>
<h4 id="this的指向">This的指向</h4>
<p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Logger {</div><div class="line">printName(name = <span class="string">'there'</span>) {</div><div class="line"><span class="keyword">this</span>.print(`Hello ${name}`);</div><div class="line">}</div><div class="line"></div><div class="line">print(text) {</div><div class="line"><span class="built_in">console</span>.log(text);</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</div><div class="line"><span class="keyword">const</span> { printName } = logger;</div><div class="line">printName(); <span class="comment">// TypeError: Cannot read property 'print' of undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Logger {</div><div class="line">constructor() {</div><div class="line"><span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>另一种解决方法是使用箭头函数。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Logger {</div><div class="line">constructor() {</div><div class="line"><span class="keyword">this</span>.printName = (name = <span class="string">'there'</span>) =&gt; {</div><div class="line"><span class="keyword">this</span>.print(`Hello ${name}`);</div><div class="line">};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>还有一种解决方法是使用<a href="#proxy">Proxy</a>，获取方法的时候，自动绑定this。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span> <span class="params">(target)</span> </span>{</div><div class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> WeakMap();</div><div class="line"><span class="keyword">const</span> handler = {</div><div class="line">get (target, key) {</div><div class="line"><span class="keyword">const</span> value = Reflect.get(target, key);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'function'</span>) {</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">}</div><div class="line"><span class="keyword">if</span> (!cache.has(value)) {</div><div class="line">cache.set(value, value.bind(target));</div><div class="line">}</div><div class="line"><span class="keyword">return</span> cache.get(value);</div><div class="line">}</div><div class="line">};</div><div class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> Proxy(target, handler);</div><div class="line"><span class="keyword">return</span> proxy;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</div></pre></td></tr></table></figure></p>
<h4 id="严格模式">严格模式</h4>
<p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。<strong>只要你的代码写在类或模块之中，就只有严格模式可用</strong>。</p>
<p>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p>
<h3 id="class的继承">Class的继承</h3>
<h4 id="基本用法-v3">基本用法</h4>
<p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ColorPoint extends Point {}</div></pre></td></tr></table></figure></p>
<p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ColorPoint extends Point {</div><div class="line">constructor(x, y, color) {</div><div class="line">super(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></div><div class="line"><span class="keyword">this</span>.color = color;</div><div class="line">}</div><div class="line"></div><div class="line">toString() {</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + super.toString(); <span class="comment">// 调用父类的toString()</span></div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p>
<p><strong>子类必须在constructor方法中调用super方法，否则新建实例时会报错</strong>。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Point { <span class="comment">/* ... */</span> }</div><div class="line"></div><div class="line"><span class="keyword">class</span> ColorPoint extends Point {</div><div class="line">constructor() {</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</p>
<p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">constructor(...args) {</div><div class="line">super(...args);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>另一个需要注意的地方是，在子类的构造函数中，<strong>只有调用super之后，才可以使用this关键字，否则会报错</strong>。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Point {</div><div class="line">constructor(x, y) {</div><div class="line"><span class="keyword">this</span>.x = x;</div><div class="line"><span class="keyword">this</span>.y = y;</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class</span> ColorPoint extends Point {</div><div class="line">constructor(x, y, color) {</div><div class="line"><span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></div><div class="line">super(x, y);</div><div class="line"><span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</p>
<p>下面是生成子类实例的代码。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(<span class="number">25</span>, <span class="number">8</span>, <span class="string">'green'</span>);</div><div class="line"></div><div class="line">cp <span class="keyword">instanceof</span> ColorPoint <span class="comment">// true</span></div><div class="line">cp <span class="keyword">instanceof</span> Point <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。</p>
<h4 id="object-getprototypeof">Object.getPrototypeOf()</h4>
<p>Object.getPrototypeOf方法可以用来从子类上获取父类。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h4 id="super关键字">super关键字</h4>
<p>super这个关键字，有两种用法，含义不同。</p>
<p>（1）作为函数调用时（即super(…args)），super代表父类的构造函数。</p>
<p>（2）作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</p>
<h3 id="new-target属性">new.target属性</h3>
<p>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>{</div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="literal">undefined</span>) {</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">} <span class="keyword">else</span> {</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new生成实例'</span>);</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 另一种写法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>{</div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) {</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">} <span class="keyword">else</span> {</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new生成实例'</span>);</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>); <span class="comment">// 正确</span></div><div class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'张三'</span>);  <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>上面代码确保构造函数只能通过new命令调用。</p>
<p>Class内部调用new.target，返回当前Class。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Rectangle {</div><div class="line">constructor(length, width) {</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</div><div class="line"><span class="keyword">this</span>.length = length;</div><div class="line"><span class="keyword">this</span>.width = width;</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是，子类继承父类时，new.target会返回子类。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Rectangle {</div><div class="line">constructor(length, width) {</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class</span> Square extends Rectangle {</div><div class="line">constructor(length) {</div><div class="line">super(length, length);</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，new.target会返回子类。</p>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类（类似Java的抽象类）。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Shape {</div><div class="line">constructor() {</div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) {</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</div><div class="line">}</div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class</span> Rectangle extends Shape {</div><div class="line">constructor(length, width) {</div><div class="line">super();</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape();  <span class="comment">// 报错</span></div><div class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 正确</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，Shape类不能被实例化，只能用于继承。</p>
<p>注意，在函数外部，使用new.target会报错。</p>
<h3 id="mixin-模式">Mixin 模式</h3>
<p>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span><span class="params">(...mixins)</span> </span>{</div><div class="line"><span class="keyword">class</span> Mix {}</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> mixin of mixins) {</div><div class="line">copyProperties(Mix, mixin);</div><div class="line">copyProperties(Mix.prototype, mixin.prototype);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">return</span> Mix;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyProperties</span><span class="params">(target, source)</span> </span>{</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key of Reflect.ownKeys(source)) {</div><div class="line"><span class="keyword">if</span> ( key !== <span class="string">"constructor"</span></div><div class="line">&& key !== <span class="string">"prototype"</span></div><div class="line">&& key !== <span class="string">"name"</span></div><div class="line">) {</div><div class="line"><span class="keyword">let</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key);</div><div class="line"><span class="built_in">Object</span>.defineProperty(target, key, desc);</div><div class="line">}</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> DistributedEdit extends mix(Loggable, Serializable) {</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<h2 id="decorator">Decorator</h2>
<h2 id="module">Module</h2>
<p>ES6 在语言规格的层面上，实现了模块功能。ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p>
<p>浏览器使用ES6模块的语法如下。</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"module"</span> <span class="attribute">src</span>=<span class="value">"foo.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个ES6模块。</p>
<p>Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。</p>
<h3 id="export命令">export命令</h3>
<p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// profile.js</span></div><div class="line">export <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line">export <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line">export <span class="keyword">var</span> year = <span class="number">1958</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码是profile.js文件，保存了用户信息。ES6将其视为一个模块，里面用export命令对外部输出了三个变量。</p>
<p>export的写法，除了像上面这样，还有另外一种。</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// profile.js</div><div class="line">var firstName = 'Michael';</div><div class="line">var lastName = 'Jackson';</div><div class="line">var year = 1958;</div><div class="line"></div><div class="line">export {firstName, lastName, year};</div></pre></td></tr></table></figure></p>
<p>上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>
<p>export命令除了输出变量，还可以输出函数或类（class）。</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export function multiply(x, y) {</div><div class="line">return x * y;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>上面代码对外输出一个函数multiply。</p>
<p>通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function v1() { ... }</div><div class="line">function v2() { ... }</div><div class="line"></div><div class="line">export {</div><div class="line">v1 as streamV1,</div><div class="line">v2 as streamV2,</div><div class="line">v2 as streamLatestVersion</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。</p>
<p>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">export 1;</div><div class="line"></div><div class="line">// 报错</div><div class="line">var m = 1;</div><div class="line">export m;</div></pre></td></tr></table></figure></p>
<p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。正确的写法是下面这样。</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 写法一</div><div class="line">export var m = 1;</div><div class="line"></div><div class="line">// 写法二</div><div class="line">var m = 1;</div><div class="line">export {m};</div><div class="line"></div><div class="line">// 写法三</div><div class="line">var n = 1;</div><div class="line">export {n as m};</div></pre></td></tr></table></figure></p>
<p>上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>
<p>同样的，function和class的输出，也必须遵守这样的写法。</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">function f() {}</div><div class="line">export f;</div><div class="line"></div><div class="line">// 正确</div><div class="line">export function f() {};</div><div class="line"></div><div class="line">// 正确</div><div class="line">function f() {}</div><div class="line">export {f};</div></pre></td></tr></table></figure></p>
<p>另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line">setTimeout(() =&gt; foo = <span class="string">'baz'</span>, <span class="number">500</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码输出变量foo，值为bar，500毫秒之后变成baz。</p>
<p>这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。</p>
<p>最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">export <span class="keyword">default</span> <span class="string">'bar'</span> <span class="comment">// SyntaxError</span></div><div class="line">}</div><div class="line">foo()</div></pre></td></tr></table></figure></p>
<p>上面代码中，export语句放在函数之中，结果报错。</p>
<h3 id="import命令">import命令</h3>
<p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"></div><div class="line">import {firstName, lastName, year} from <span class="string">'./profile'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span><span class="params">(element)</span> </span>{</div><div class="line">element.textContent = firstName + <span class="string">' '</span> + lastName;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码的import命令，就用于加载profile.js文件，并从中输入变量。import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。</p>
<p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import { lastName as surname } from <span class="string">'./profile'</span>;</div></pre></td></tr></table></figure></p>
<p>注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"></div><div class="line">import { foo } from <span class="string">'my_module'</span>;</div></pre></td></tr></table></figure></p>
<p>上面的代码不会报错，因为import的执行早于foo的调用。</p>
<p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">export { es6 as <span class="keyword">default</span> } from <span class="string">'./someModule'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">import { es6 } from <span class="string">'./someModule'</span>;</div><div class="line">export <span class="keyword">default</span> es6;</div></pre></td></tr></table></figure></p>
<p>上面代码中，export和import语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，而应该采用标准写法。</p>
<p>另外，ES7有一个提案，简化先输入后输出的写法，拿掉输出时的大括号。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 提案的写法</span></div><div class="line">export v from <span class="string">'mod'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 现行的写法</span></div><div class="line">export {v} from <span class="string">'mod'</span>;</div></pre></td></tr></table></figure></p>
<p>import语句会执行所加载的模块，因此可以有下面的写法。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import <span class="string">'lodash'</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码仅仅执行lodash模块，但是不输入任何值。</p>
<h4 id="模块的整体加载">模块的整体加载</h4>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import * as circle from './circle';</div><div class="line"></div><div class="line">console.log('圆面积：' + circle.area(4));</div><div class="line">console.log('圆周长：' + circle.circumference(14));</div></pre></td></tr></table></figure></p>
<h3 id="export-default-命令">export default 命令</h3>
<p>export default命令可以为模块指定默认输出。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export-default.js</span></div><div class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码是一个模块文件export-default.js，它的默认输出是一个函数。</p>
<p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import-default.js</span></div><div class="line">import customName from <span class="string">'./export-default'</span>;</div><div class="line">customName(); <span class="comment">// 'foo'</span></div></pre></td></tr></table></figure></p>
<p>export default命令用在非匿名函数前，也是可以的。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export-default.js</span></div><div class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 或者写成</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">}</div><div class="line"></div><div class="line">export <span class="keyword">default</span> foo;</div></pre></td></tr></table></figure></p>
<p>下面比较一下默认输出和正常输出。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输出</span></div><div class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span><span class="params">()</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div><div class="line"><span class="comment">// 输入</span></div><div class="line">import crc32 from <span class="string">'crc32'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line">export <span class="function"><span class="keyword">function</span> <span class="title">crc32</span><span class="params">()</span> </span>{</div><div class="line"><span class="comment">// ...</span></div><div class="line">};</div><div class="line"><span class="comment">// 输入</span></div><div class="line">import {crc32} from <span class="string">'crc32'</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。</p>
<p>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export deault命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</p>
<p>export default也可以用来输出类。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyClass.js</span></div><div class="line">export <span class="keyword">default</span> <span class="keyword">class</span> { ... }</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line">import MyClass from <span class="string">'MyClass'</span>;</div><div class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyClass();</div></pre></td></tr></table></figure></p>
<h3 id="模块的继承">模块的继承</h3>
<p>模块之间也可以继承。</p>
<p>假设有一个circleplus模块，继承了circle模块。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// circleplus.js</span></div><div class="line"></div><div class="line">export * from <span class="string">'circle'</span>;</div><div class="line">export <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</div><div class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{</div><div class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。</p>
<p>这时，也可以将circle的属性或方法，改名后再输出。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// circleplus.js</span></div><div class="line"></div><div class="line">export { area as circleArea } from <span class="string">'circle'</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。</p>
<p>加载上面模块的写法如下。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"></div><div class="line">import * as math from <span class="string">'circleplus'</span>;</div><div class="line">import exp from <span class="string">'circleplus'</span>;</div><div class="line"><span class="built_in">console</span>.log(exp(math.e));</div></pre></td></tr></table></figure></p>
<p>上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。</p>
<h3 id="es6模块的转码">ES6模块的转码</h3>
<p>浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。除了Babel可以用来转码之外，还有以下两个方法，也可以用来转码。</p>
<ol>
<li><a href="https://github.com/esnext/es6-module-transpiler" target="_blank" rel="external">ES6 module transpiler</a> - square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。</li>
<li><a href="https://github.com/systemjs/systemjs" target="_blank" rel="external">SystemJS</a> - 它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google的Traceur转码器。</li>
</ol>
<h2 id="本文参考材料">本文参考材料</h2>
<ul>
<li><a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="external">阮一峰 - ECMAScript 6 入门</a></li>
</ul>
<h2 id="深入阅读">深入阅读</h2>
<ul>
<li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html" target="_blank" rel="external">ES6 规范</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/7.0/index.html" target="_blank" rel="external">ES7 规范</a></li>
</ul>


		<!-- pagination -->
		<div>
		<center>
		<div class="pagination">
<ul class="pagination">
	
	
	
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
			
		
	
	    
	
	    
			
			
		
	
	    
			
			
			
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	
		<li class="prev"><a data-pjax href="/wiki/javascript-es5.html" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
	
	<li><a data-pjax href="/wiki"><i class="fa fa-tasks"></i>Wiki</a></li>
	
		<li class="next"><a data-pjax href="/wiki/javascript-tools.html" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

	    </center>
		</div>
				
		<!-- toc -->
		
   	<script type="text/javascript">
		jQuery(document).ready(function() {
		
 		   generateWikiTOC('.note', '.toc',  2 , 2 );
		
		});
	</script>



				
		<!-- comment -->
		
<section id="comment">
    <h2 class="title">Comments</h2>
	
	 <div id="comment-thread"></div>
	 <div id="loading-spin"></div>
	 <script type="text/javascript">
	   getComments({
		       type: "github",
	           user: "wzpan",
	           repo: "wzpan.github.io",
			   client_id: "1eb35434de75c06a513f",
			   client_secret: "6e4193f8ecd619cdfac2b1aa16b3663fe18d2e90",
			   no_comment: "暂时还没有留言呢，点击下面的按钮去留言吧！",
			   go_to_comment: "去留言",
			   btn_class: "btn btn-primary",
			   no_issue: "no_issue",
			   issue_title: "ES6",
			   issue_id: "undefined",
			   comments_target: "#comment-thread" ? "#comment-thread" : "#comment-thread",
			   loading_target: "undefined"
			   });
	 </script>
	
</section>


		

	</div> <!-- span9/span12 -->
</div><!-- row-fluid post-full -->

	</div>	
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2019 Joseph Pan
  
    <small>
     <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"><img title="知识共享许可协议" style="border-width: 0px; vertical-align: middle; display: inline; " src="/images/license.png"></a>
    </small>
</p>
 </footer>
</div> <!-- container-narrow -->


<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/dist/jquery.imagesloaded.min.js"></script>


<script src="/dist/gallery.min.js"></script>
<script src="/dist/bootstrap.min.js"></script>
<script src="/dist/jquery.tableofcontents.min.js"></script>
<script src="/dist/tocgenerator.min.js"></script>
<script src="/dist/require.min.js"></script>
<script src="/dist/main.min.js"></script>



<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox({
    helpers : { 
        title : { type : 'inside' }
    },
    afterLoad : function() {
        this.title = (this.title ? '' + this.title + '<br />' : '') + 'Image ' + (this.index + 1) + ' of ' + this.group.length;
    }
  });
})(jQuery);
</script>




<!-- syntax highlighting -->

  <script>
  marked.setOptions({
    highlight: function (code, lang) {
        return hljs.highlightAuto(code).value;
    }
  });
  function Highlighting(){
    var markdowns = document.getElementsByClassName('markdown');
    for(var i=0;i<markdowns.length;i++){
        if(markdowns[i].innerHTML) markdowns[i].innerHTML =marked(markdowns[i].innerHTML);
    }
  }
  window.addEventListener('DOMContentLoaded', Highlighting, false);
  window.addEventListener('load', Highlighting, false);
  </script>



<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','ney3Rb77vMaWT2KUKFyt');
</script>





</body>
</html>
