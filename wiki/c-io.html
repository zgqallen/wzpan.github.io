<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>输入输出 | HaHack</title>
  <meta name="author" content="Joseph Pan">
  
  <meta name="description" content="流的概念
流是磁盘或其他外围设备中存储的数据的源点或终点。尽管在一些系统中(如在著名的UNIX系统中)，文本流和二进制流是没有差别的，但是标准库中还是提供了这两种流。
文本流是由文本行组成的序列，每一行有 0个或多个字符并以 \n 结尾。在某些环境中也许需要把文本流转换成其他表示形式(例如把 \n ">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="输入输出"/>
  <meta property="og:site_name" content="HaHack"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/images/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="HaHack" type="application/atom+xml">
  
  <link rel="stylesheet" href="/dist/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/bootstrap-responsive.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/font-awesome.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/style.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/highlight.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/sidenav.min.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/dist/responsive.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/bubble.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/google-fonts.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/nprogress.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/comment.min.css" media="screen" type="text/css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <!--[if lte IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

<!--  -->
<!--     <link href='http://fonts.googleapis.com/css?family=PT+Sans+Narrow|PT+Sans:400,400italic,700,700italic|Droid+Serif:400,400italic' rel='stylesheet' type='text/css'> -->
<!--     <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'> -->
<!--  -->
  
<script src="/dist/jquery-2.0.3.min.js"></script>


    <script src="/dist/videoGFW.min.js"></script>
	
	


    <script src="/dist/comment.js"></script>
    <script src="/dist/markdown.min.js"></script>
    <script src="/dist/timeago.min.js"></script>
	<script src="/dist/spin.min.js"></script>


</head>


<body data-spy="scroll" data-target=".toc">  
  <header id="header" class="inner"><div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
            <a data-pjax class="brand" href="/">HaHack</a>
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <div class="nav-collapse collapse">
            <ul class="nav">				
			    
				   <li><a data-pjax href="/archive" title="所有文章归档"><i class="fa fa-archive"></i>Archive</a></li>				   			    			
				   <li><a data-pjax href="/categories" title="所有文章分类"><i class="fa fa-folder"></i>Categories</a></li>				   			    			
				   <li><a data-pjax href="/tags" title="所有文章标签"><i class="fa fa-tags"></i>Tags</a></li>				   			    			
				
				<li class="divider-vertical"></li>
			   	<li><a data-pjax href="/wiki" title="我的笔记库"><i class="fa fa-tasks"></i>wiki</a></li>				   
				
            </ul>			
			<ul class="nav navright">
				<li class="dropdown">
				<a data-pjax href="#" title="订阅本站" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-rss"></i>Subscribe <b class="caret"></b></a>
                                <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="/atom.xml" title="使用 RSS 阅读器订阅 HaHack"><i class="fa fa-rss-square"></i>RSS</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="/wechat.html" title="订阅 HaHack 的公众平台"><i class="fa fa-qrcode"></i>WeChat</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="http://toutiao.io/u/147640" title=""><i class="fa fa-align-justify"></i>Toutiao</a></li>
				
                	        </ul>
				</li>
				
				<li><a data-pjax href="/about" title="关于我"><i class="fa fa-user"></i>About</a></li>				   				
   					  
            </ul>
            </div> <!-- nav-collapse collapse -->
        </div> <!-- container -->
     </div> <!-- navbar-inner -->
</div> <!-- navbar navbar-inverse -->
</header>
  <div class="container" id="container">
  	<div class="content">
    	 

	
		<div class="page-header">		
			<h1> 输入输出</h1>
		</div>    
	



<div class="row-fluid wiki">
	<!-- span -->
    
        <div class="span3 toc"></div>
        <div class="span9 note">
    

	

		<!-- content -->
		<h2 id="流的概念">流的概念</h2>
<p>流是磁盘或其他外围设备中存储的数据的源点或终点。尽管在一些系统中(如在著名的UNIX系统中)，文本流和二进制流是没有差别的，但是标准库中还是提供了这两种流。</p>
<p>文本流是由文本行组成的序列，每一行有 0个或多个字符并以 <code>\n</code> 结尾。在某些环境中也许需要把文本流转换成其他表示形式(例如把 <code>\n</code> 映射成回车符和换行符)或从其他表示形式转换过来。二进制流是未经处理的字节组成的序列，这些字节记录着内部数据，具有如下性质：如果在同一系统中把写出的二进制流再读入进来，读入的和写出的内容是完全相同的。</p>
<p>通过打开一个流可以将该流与一个文件或设备关联起来，这一关联可以通过关闭流而终止。<strong>打开一个文件将返回一个指向 FILE 类型对象的指针，该指针中记录有用于控制该流的所有必要的信息</strong>。在不会引起歧义性的情况下，我们在下文中将不再区分“文件指针”和“流”。</p>
<p>在程序开始执行时，stdin、stdout 和 stderr 这三个流已经被打开。</p>
<h2 id="格式化输入输出">格式化输入输出</h2>
<h3 id="格式化输出">格式化输出</h3>
<p>printf 类函数用于提供格式化的输出转换。</p>
<h4 id="格式化字符">格式化字符</h4>
<p>格式化字符串由两种类型的对象组成：普通字符(它们被拷贝到输出流)与转换规格说明(它们决定参数的转换和输出格式)。每个转换规格说明均以字符 <code>%</code> 开头,以转换字符结束。</p>
<h4 id="printf转换说明的可选项">printf转换说明的可选项</h4>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td>八进制前面加0（转换字符为o），十六进制前面加0x（转换字符为x）或0X（转换字符为X）。</td>
<td><code>printf(&quot;%#x&quot;, 0xff)</code>打印<code>0xff</code>，<code>printf(&quot;%x&quot;, 0xff)</code>打印<code>ff</code>。</td>
</tr>
<tr>
<td>-</td>
<td>格式化后的内容居左，右边可以留空格。</td>
<td>见下面的例子</td>
</tr>
<tr>
<td>宽度</td>
<td>用一个整数指定格式化后的最小长度，如果格式化后的内容没有这么长，可以在左边留空格，如果前面指定了-号就在右边留空格。宽度有一种特别的形式，不指定整数值而是写成一个 * 号，表示取一个int型参数作为宽度。</td>
<td><code>printf(&quot;-%10s-&quot;, &quot;hello&quot;)</code>打印<code>-␣␣␣␣␣hello-</code>，<code>printf(&quot;-%-*s-&quot;, 10, &quot;hello&quot;)</code>打印<code>-hello␣␣␣␣␣-</code>。</td>
</tr>
<tr>
<td>.</td>
<td>用于分隔上一条提到的最小长度和下一条要讲的精度。</td>
<td>见下面的例子</td>
</tr>
<tr>
<td>精度</td>
<td>用一个整数表示精度。精度也可以不指定整数值而是写成一个 * 号，表示取下一个int型参数作为精度。</td>
<td><code>printf(&quot;%.4s&quot;, &quot;hello&quot;)</code>打印<code>hell</code>，<code>printf(&quot;-%6.4d-&quot;, 100)</code>打印<code>-␣␣0100-</code>，<code>printf(&quot;-%*.*f-&quot;, 8, 4, 3.14)</code>打印<code>-␣␣3.1400-</code>。</td>
</tr>
<tr>
<td>字长</td>
<td>对于整型参数，hh、h、l、ll分别表示是char、short、long、long long型的字长，至于是有符号数还是无符号数则取决于转换字符；对于浮点型参数，L表示long double型的字长。</td>
<td><code>printf(&quot;%hhd&quot;, 255)</code>打印<code>-1</code>。</td>
</tr>
</tbody>
</table>
<h4 id="printf-常用的转换字符">printf 常用的转换字符</h4>
<p>在 <code>%</code> 与转换字符这二者之间依次可以有以下转换字符：</p>
<table>
<thead>
<tr>
<th>格式码</th>
<th>参数类型：转换效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d</code>, <code>i</code></td>
<td>int: 有符号十进制表示法</td>
</tr>
<tr>
<td><code>o</code></td>
<td>int；无符号八进制表示法(无前导 0)</td>
</tr>
<tr>
<td><code>x</code>, <code>X</code></td>
<td>int；无符号十六进制表示法(无前导 0 X和0x),对0x用abcdef,对0X用ABCDEF</td>
</tr>
<tr>
<td><code>u</code></td>
<td>int；无符号十进制表示法</td>
</tr>
<tr>
<td><code>c</code></td>
<td>int；单个字符,转换为 unsigned char类型后</td>
</tr>
<tr>
<td><code>s</code></td>
<td>char *；输出字符串直到遇到 <code>\0</code>或者已达到由精度指定的字符数</td>
</tr>
<tr>
<td><code>f</code></td>
<td>double；形如[-] mmm.ddd的十进制浮点数表示法，d的数目由精度确定。缺省精度为6位，精度为0时不输出小数点</td>
</tr>
<tr>
<td><code>e</code>, <code>E</code></td>
<td>double；形如[-]m.d ddddde±xx或[-] m .dddd ddE±xx的十进制表示法。d的数目由精度确定，缺省精度为6位。精度为0时不输出小数点</td>
</tr>
<tr>
<td><code>g</code>, <code>G</code></td>
<td>double；当指数值小于-4或大于等于精度时,采用 <code>%e</code> 或<code>%E</code>格式；否则采用 <code>%f</code> 的格式。尾部的0与小数点不打印</td>
</tr>
<tr>
<td><code>p</code></td>
<td>void *；输出指针值(具体表示与实现有关)</td>
</tr>
<tr>
<td><code>n</code></td>
<td>int *；到目前为止以此格式调用 printf 输出的字符的数目将被写入到相应参数中。</td>
</tr>
<tr>
<td><code>%</code></td>
<td>不进行参数转换；输出符号 <code>%</code></td>
</tr>
</tbody>
</table>
<h4 id="fprintf">fprintf</h4>
<p>fprintf函数用于按照 format 说明的格式把参数列表中参数的内容进行转换，并写入stream指向的流。返回值是实际写入的字符数。若出错则返回一个负值。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">fprintf</span>(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</div></pre></td></tr></table></figure></p>
<h4 id="printf">printf</h4>
<p><code>printf(...)</code> 函数等价于 <code>fprintf(stdout, ...)</code></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">printf</span>(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</div></pre></td></tr></table></figure></p>
<h4 id="sprintf">sprintf</h4>
<p>sprintf 函数与 printf 函数的功能基本相同，但输出到数组 s 中，并以 <code>\0</code> 结束。 s必须足够大，以便能装下输出结果。该函数返回实际输出的字符数，不包括 <code>\0</code>。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">sprintf</span>(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...);</div></pre></td></tr></table></figure></p>
<h4 id="snprintf">snprintf</h4>
<p>sprintf并不打印到文件，而是打印到用户提供的缓冲区str中并在末尾加’\0’，由于格式化后的字符串长度很难预计，所以很可能造成缓冲区溢出，用snprintf更好一些，参数size指定了缓冲区长度，如果格式化后的字符串长度超过缓冲区长度，snprintf就把字符串截断到size-1字节，再加上一个’\0’写入缓冲区，也就是说snprintf保证字符串以’\0’结尾。snprintf的返回值是格式化后的字符串长度（不包括结尾的’\0’），如果字符串被截断，返回的是截断之前的长度，把它和实际缓冲区中的字符串长度相比较就可以知道是否发生了截断。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">snprintf</span>(<span class="keyword">char</span> *str, size_t size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...);</div></pre></td></tr></table></figure></p>
<h4 id="vprintf-vfprintf-与-vsprintf">vprintf, vfprintf 与 vsprintf</h4>
<p>vprintf、vfprintf 与 vsprintf 这几个函数与对应的 printf 函数等价，但参数列表由 <a href="/wiki/c/%E6%A0%87%E5%87%86%E5%BA%93#stdarg.h">arg</a> 代替。 arg由宏 <code>va_start</code> 初始化，由 <code>va_arg</code> 调用。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vprintf</span>(<span class="keyword">const</span> <span class="keyword">char</span> *format, va_list arg)</div><div class="line"><span class="built_in">vfprintf</span>(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list arg)</div><div class="line"><span class="built_in">vsprintf</span>(<span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list arg)</div></pre></td></tr></table></figure></p>
<p>示例：实现格式化打印错误的err_sys函数</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#include <stdio.h></stdio.h></div><div class="line">#include <stdlib.h></stdlib.h></div><div class="line">#include <errno.h></errno.h></div><div class="line">#include <stdarg.h></stdarg.h></div><div class="line">#include <string.h></string.h></div><div class="line"></div><div class="line">#define MAXLINE 80</div><div class="line"></div><div class="line">void err_sys(const char *fmt, ...)</div><div class="line">{</div><div class="line">    int err = errno;</div><div class="line">    char buf[MAXLINE+1];</div><div class="line">    va_list ap;</div><div class="line"></div><div class="line">    va_start(ap, fmt);</div><div class="line"></div><div class="line">    vsnprintf(buf, MAXLINE, fmt, ap);</div><div class="line">    snprintf(buf+strlen(buf), MAXLINE-strlen(buf), ": %s", strerror(err));</div><div class="line">    strcat(buf, "\n");</div><div class="line">    fputs(buf, stderr);</div><div class="line"></div><div class="line">    va_end(ap);</div><div class="line">    exit(1);</div><div class="line">}</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">{</div><div class="line">    FILE *fp;</div><div class="line">    if (argc != 2) {</div><div class="line">        fputs("Usage: ./a.out pathname\n", stderr);</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line">    fp = fopen(argv[1], "r");</div><div class="line"></div><div class="line">    if (fp == NULL)</div><div class="line">        err_sys("Line %d - Open file %s", __LINE__, argv[1]);</div><div class="line">    printf("Open %s OK\n", argv[1]);</div><div class="line">    fclose(fp);</div><div class="line">    return 0;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="格式化输入">格式化输入</h3>
<p>scanf 类函数用于提供格式化输入转换。</p>
<h4 id="格式化字符-v2">格式化字符</h4>
<p>格式字符串 format 通常包含有用于指导输入转换的转换规格说明。格式字符串中可以包含：</p>
<ul>
<li>空格或制表符，它们将被忽略。</li>
<li>普通字符(“%”除外)，与输入流中下一个非空白的字符相匹配。</li>
<li>转换规格说明，由一个 %、一个赋值屏蔽字符 *(任选)、一个用于指定最大字段宽的数(任选)、一个用于指定目标字段的字符 (h、l或 L )(任选)以及一个转换字符组成。</li>
</ul>
<p>转换规格说明决定了输入字段的转换方式。通常把结果保存在由对应参数指向的变量中。然而，如果转换规格说明中包含有赋值屏蔽字符“*”，例如<code>% *s</code>，那么就跳过对应的输入字段，不进行赋值。输入字段是一个由非空白符组成的字符串，当遇到空白符或到达最大字段宽(如果有的话)时，对输入字段的读入结束。这意味着 scanf 函数可以跨越行的界限来读入其输入，因为换行符也是空白符(空白符包括空格、横向制表符、纵向制表符、换行符、回车符和换页符)。</p>
<p>转换字符说明了输入字段的解释含义,对应的参数必须是指针。合法的转换符如下表所示。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>输入数据；参数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d</code></td>
<td>十进制整数； int *</td>
</tr>
<tr>
<td><code>i</code></td>
<td>整数；int * 。该整数可以是以 0开头的八进制数，也可以是以 0x 或 0X 开头的十六进制数</td>
</tr>
<tr>
<td><code>o</code></td>
<td>八进制整数(可以带或不带前导 0)；int *</td>
</tr>
<tr>
<td><code>u</code></td>
<td>无符号十进制整数； unsigned int *</td>
</tr>
<tr>
<td><code>x</code></td>
<td>十六进制整数(可以带或不带前导 0x 或 0X)；int *</td>
</tr>
<tr>
<td><code>c</code></td>
<td>字符；char * 。按照字段宽的大小把读入的字符保存在指定的数组中，不加入字符 <code>\0</code>。字段宽的缺省值为 1。在这种情况下，不跳过空白符 ；如果要读入下一个非空白符，使用 <code>%1s</code></td>
</tr>
<tr>
<td><code>s</code></td>
<td>由非空白符组成的字符串(不包含引号)； char*。该参数指针指向一个字符数组，该字符数组有足够空间来保存该字符串以及在末尾添加的 <code>\0</code></td>
</tr>
<tr>
<td><code>e</code>、<code>f</code>、<code>g</code></td>
<td>浮点数；float *。float 浮点数的输入格式为：一个任选的正负号，一串可能包含小数点的数字和一个任选的指数字段。指数字段由字母 e 或 E 以及后跟的一个可能带正负号的整数组成</td>
</tr>
<tr>
<td><code>p</code></td>
<td>用<code>printf(&quot;%p&quot;)</code>函数调用输出的指针值； void *</td>
</tr>
<tr>
<td><code>n</code></td>
<td>将到目前为止此调用所读的字符数写入参数； int * 。</td>
</tr>
<tr>
<td><code>[...]</code></td>
<td>不读入输入字符。不增加转换项目计数用方括号括起的字符集中的字符来匹配输入，以找到最长的非空字符串； char *。在末尾添加字符<code>\0</code>。格式 <code>[]...]</code> 表示字符集中包含字符 <code>]</code></td>
</tr>
<tr>
<td><code>[^...]</code></td>
<td>用不在方括号括起的字符集中的字符来匹配输入，以找到最长的非空字符串； char *。在末尾添加字符<code>\0</code>。格式 <code>[ ^ ]. ..]</code> 表示字符集中包含字符 <code>]</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>字面值%，不进行赋值</td>
</tr>
</tbody>
</table>
<h4 id="fscanf">fscanf</h4>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">fscanf</span>(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</div></pre></td></tr></table></figure></p>
<p>fscanf 函数用于在格式串 format 的控制下从流stream中读入字符，把转换后的值赋给后续各个参数，在此每一个参数都必须是一个指针。当格式串 format 结束时函数返回。如果到达文件的末尾或在参数被转换前出错，那么该函数返回 EOF；否则返回实际被转换并赋值的输入项的数目。</p>
<h4 id="scanf">scanf</h4>
<p><code>scanf(...)</code>函数等价于<code>fscanf(stdin, ...)</code></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">scanf</span>(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</div></pre></td></tr></table></figure></p>
<h5 id="示例">示例</h5>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">float</span> value;</div><div class="line"></div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &num);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%f"</span>, &value);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, value);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="sscanf">sscanf</h4>
<p><code>sscanf(s, ...)</code>函数与<code>scanf (... )</code>等价,不同的是前者的输入字符来源于 s。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">sscanf</span>(<span class="keyword">char</span> *s,<span class="keyword">const</span> *format, ... )</div></pre></td></tr></table></figure></p>
<h2 id="文件输入输出">文件输入输出</h2>
<h3 id="fopen">fopen</h3>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FILE *fopen(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</div></pre></td></tr></table></figure></p>
<p>fopen函数用于打开以filename所指内容为名字的文件,返回与之相关联的流。如果打开操作失败,那么返回 NULL。</p>
<p>访问方式mode的合法值如下:</p>
<table>
<thead>
<tr>
<th>值</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>“r”</td>
<td>打开文本文件用于读。</td>
</tr>
<tr>
<td>“w”</td>
<td>创建文本文件用于写,并删除已存在的内容(如果有的话)。</td>
</tr>
<tr>
<td>“a”</td>
<td>添加；打开或创建文本文件用于在文件末尾写。</td>
</tr>
<tr>
<td>“r+”</td>
<td>打开文本文件用于更新(即读和写)。</td>
</tr>
<tr>
<td>“w+”</td>
<td>创建文本文件用于更新,并删除已存在的内容(如果有的话)。</td>
</tr>
<tr>
<td>“a+”</td>
<td>添加、打开或创建文本文件用于更新和在文件末尾写。</td>
</tr>
</tbody>
</table>
<p>后三种方式允许对同一文件进行读和写。在读和写的交替过程中,必须调用 <a href="#fflush">fflush</a> 函数或文件定位函数。如果方式值在上述字符之后再加上 “b” ,如 “rb” 或 &quot;w+b &quot;等，那么表示文件是二进制文件。文件名 filename 长度的最大值为 <code>FILENAME_MAX</code> 个字符。一次最多可打开 <code>FOPEN_MAX</code> 个文件。</p>
<p>在打开一个文件时如果出错，fopen将返回NULL并设置errno，errno稍后介绍。在程序中应该做出错处理，通常这样写：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( (fp = fopen(<span class="string">"/tmp/file1"</span>, <span class="string">"r"</span>)) == NULL) {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"error open file /tmp/file1!\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="freopen">freopen</h3>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FILE *freopen(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</div></pre></td></tr></table></figure></p>
<p>freopen 函数用于以参数 mode 指定的方式打开参数 filename 指定的文件，并使该文件与参数 stream 指定的流相关联。它返回指向 stream 的指针；若出错则返回 NULL。freopen 函数一般用于
stdin、stdout 和 stderr 等标准流的重定向。</p>
<h3 id="fflush">fflush</h3>
<p>用户程序调用fputc通常只是写到I/O缓冲区中，这样fputc函数可以很快地返回，如果I/O缓冲区写满了，fputc就通过系统调用把I/O缓冲区中的数据传给内核，内核最终把数据写回磁盘。有时候用户程序希望把I/O缓冲区中的数据立刻传给内核，让内核写回设备，这称为Flush操作，对应的库函数是fflush，fclose函数在关闭文件之前也会做Flush操作。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fflush(FILE *stream)</div></pre></td></tr></table></figure></p>
<p>对输出流, fflush 函数用于将已写到缓冲区但尚未写出的全部数据都写到文件中。对输入流，其结果是未定义的。如果写的过程中发生错误则返回 EOF ，否则返回 0。fflush(NULL)函数用于刷新所有的输出流。</p>
<h4 id="c标准库的-i-o-缓冲区">C标准库的 I/O 缓冲区</h4>
<p><img src="/images/c-io/stdlib.buffer.png" alt="C标准库的I/O缓冲区"></p>
<p>C标准库的I/O缓冲区有三种类型：全缓冲、行缓冲和无缓冲。当用户程序调用库函数做写操作时，不同类型的缓冲区具有不同的特性。</p>
<ul>
<li>全缓冲：如果缓冲区写满了就写回内核。常规文件通常是全缓冲的。</li>
<li>行缓冲：如果用户程序写的数据中有换行符就把这一行写回内核，或者如果缓冲区写满了就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的。</li>
<li>无缓冲：用户程序每次调库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备。</li>
</ul>
<h3 id="fclose">fclose</h3>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fclose(FILE *stream)</div></pre></td></tr></table></figure></p>
<p>fclose函数用于刷新 stream 的全部未写出数据，丢弃任何未读的缓冲区内的输入数据并释放自动分配的缓冲区，最后关闭流。若出错则返回 EOF，否则返回 0。</p>
<p><div class="alert alert-error"><i class="fa fa-bug"></i>  <p>fopen调用应该和fclose调用配对，打开文件操作完之后一定要记得关闭。如果不调用fclose，在进程退出时系统会自动关闭文件，但是不能因此就忽略fclose调用，如果写一个长年累月运行的程序（比如网络服务器程序），打开的文件都不关闭，堆积得越来越多，就会占用越来越多的系统资源。</p>
</div></p>
<p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>关于fopen、fgetc、fputc、fclose几个函数的底层实现可以参考[Unbuffered I/O](/wiki/kernel/Unbuffered I/O)一节的内容</p>
</div></p>
<h2 id="字符输入输出">字符输入输出</h2>
<h3 id="fgetc">fgetc</h3>
<p>fgetc 函数用于以 unsigned char 类型返回 stream 流中的下一个字符(转换为 int 类型)。如果到达文件的末尾或发生错误，则返回 EOF。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fgetc(FILE *stream)</div></pre></td></tr></table></figure></p>
<p>对于fgetc函数的使用有以下几点说明：</p>
<ul>
<li>要用fgetc函数读一个文件，该文件的打开方式必须是可读的。</li>
<li>系统对于每个打开的文件都记录着当前读写位置在文件中的地址（或者说距离文件开头的字节数），也叫偏移量（Offset）。当文件打开时，读写位置是0，每调用一次fgetc，读写位置向后移动一个字节，因此可以连续多次调用fgetc函数依次读取多个字节。</li>
<li>fgetc成功时返回读到一个字节，本来应该是unsigned char型的，但由于函数原型中返回值是int型，所以这个字节要转换成int型再返回，那为什么要规定返回值是int型呢？因为出错或读到文件末尾时fgetc将返回EOF，即-1，保存在int型的返回值中是0xffffffff，如果读到字节0xff，由unsigned char型转换为int型是0x000000ff，只有规定返回值是int型才能把这两种情况区分开，如果规定返回值是unsigned char型，那么当返回值是0xff时无法区分到底是EOF还是字节0xff。<strong>如果需要保存fgetc的返回值，一定要保存在int型变量中</strong>，如果写成unsigned char c = fgetc(fp);，那么根据c的值又无法区分EOF和0xff字节了。注意，fgetc读到文件末尾时返回EOF，只是用这个返回值表示已读到文件末尾，并不是说每个文件末尾都有一个字节是EOF（根据上面的分析，EOF并不是一个字节）。</li>
</ul>
<h3 id="fputc">fputc</h3>
<p>fputc函数用于把字符 c(转换为 unsigned char类型)输出到流 stream 中。它返回所写的字符，若出错则返回EOF。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fputc(<span class="keyword">int</span> c, FILE *stream)</div></pre></td></tr></table></figure></p>
<p>对于fputc函数的使用也要说明几点：</p>
<ul>
<li>要用fputc函数写一个文件，该文件的打开方式必须是可写的（包括追加）。</li>
<li>每调用一次fputc，读写位置向后移动一个字节，因此可以连续多次调用fputc函数依次写入多个字节。但如果文件是以追加方式打开的，每次调用fputc时总是将读写位置移到文件末尾然后把要写入的字节追加到后面。</li>
</ul>
<h3 id="getc">getc</h3>
<p>getc函数等价于 fgetc，不同之处为：当 getc 函数被定义为宏时，它可能多次计算 stream 的值。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> getc(FILE *stream)</div></pre></td></tr></table></figure></p>
<h3 id="getchar">getchar</h3>
<p>getchar函数等价于 getc(stdin)。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> getchar(<span class="keyword">void</span>)</div></pre></td></tr></table></figure></p>
<h3 id="putc">putc</h3>
<p>putc 函数等价于 fputc，不同之处为：当 putc 函数被定义为宏时，它可能多次计算 stream 的值。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> putc(<span class="keyword">int</span> c, FILE *stream)</div></pre></td></tr></table></figure></p>
<h3 id="putchar">putchar</h3>
<p>putchar© 函数等价于 putc(c, stdout)。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">putchar</span>(<span class="keyword">int</span> c)</div></pre></td></tr></table></figure></p>
<h3 id="ungetc">ungetc</h3>
<p>ungetc用于把字符 c(转换为 unsigned char类型)写回到流 stream 中，下次对该流进行读操作时，将返回该字符。对每个流只能写回一个字符，且此字符不能是 EOF。ungetc函数返回被写回的字符；如果发生错误，那么它返回 EOF。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ungetc(<span class="keyword">int</span> c, FILE *stream)</div></pre></td></tr></table></figure></p>
<h2 id="字符串输入输出">字符串输入输出</h2>
<h3 id="fgets">fgets</h3>
<p>fgets函数用于读入最多 n-1 个字符到数组 s 中。当遇到换行符 <code>\n</code> 时，把换行符保留在数组s中，读入不再进行。数组 s以 <code>\0</code> 结尾。 fgets 函数返回数组 s，如果到达文件的末尾或发生错误，则返回 NULL。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *fgets(<span class="keyword">char</span> *s, <span class="keyword">int</span> n, FILE *stream)</div></pre></td></tr></table></figure></p>
<p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>对于fgets来说，<code>\n</code> 是一个特别的字符，而 <code>\0</code> 并无任何特别之处，如果读到 <code>\0</code> 就当作普通字符读入。如果文件中存在 <code>\0</code> 字符（或者说0x00字节），调用fgets之后就无法判断缓冲区中的 <code>\0</code> 究竟是从文件读上来的字符还是由fgets自动添加的结束符，所以fgets只适合读文本文件而不适合读二进制文件，并且文本文件中的所有字符都应该是可见字符，不能有 <code>\0</code> 。</p>
</div></p>
<h3 id="fputs">fputs</h3>
<p>fputs函数用于把字符串 s(不包含字符 <code>\n</code>)输出到流 stream 中；它返回一个非负值，若出错则返回EOF。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">fputs</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</div></pre></td></tr></table></figure></p>
<h3 id="gets">gets</h3>
<p>gets函数用于把下一个字符串读入到数组 s 中，并把读入的换行符替换为字符 <code>\0</code> 。它返回数组s，如果到达文件的末尾或发生错误则返回 NULL。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *gets(<span class="keyword">char</span> *s)</div></pre></td></tr></table></figure></p>
<p><div class="alert alert-error"><i class="fa fa-bug"></i>  <p><strong>Never use gets()</strong>。gets函数的存在只是为了兼容以前的程序，我们写的代码都不应该调用这个函数。gets函数的接口设计得很有问题，就像strcpy一样，用户提供一个缓冲区，却不能指定缓冲区的大小，很可能导致缓冲区溢出错误，这个函数比strcpy更加危险，strcpy的输入和输出都来自程序内部，只要程序员小心一点就可以避免出问题，而gets读取的输入直接来自程序外部，用户可能通过标准输入提供任意长的字符串，程序员无法避免gets函数导致的缓冲区溢出错误，所以唯一的办法就是不要用它。</p>
</div></p>
<h3 id="puts">puts</h3>
<p>puts函数用于把字符串 s 和一个换行符输出到 stdout。如果发生错误，那么它返回 EOF；否则返回一个非负值。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">puts</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s)</div></pre></td></tr></table></figure></p>
<h2 id="直接输入输出">直接输入输出</h2>
<h3 id="fread">fread</h3>
<p>fread函数用于从输入流 stream 中读入最多 nobj 个长度为 size 的对象到 ptr 指向的数组中，并返回所读入的对象数，此返回值可能小于 nobj。实际执行状态可用函数 feof 或 ferror 得到。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size_t fread(<span class="keyword">void</span> *ptr, size_t size, size_t nobj, FILE *stream)</div></pre></td></tr></table></figure></p>
<h3 id="fwrite">fwrite</h3>
<p>fwrite 函数用于把 ptr 所指向的数组中 nobj 个长度为 size 的对象输出到流 stream 中，并返回被输出的对象数。如果发生错误，则返回一个小于 nobj 的值。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size_t fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, size_t size, size_t nobj, FILE *stream)</div></pre></td></tr></table></figure></p>
<h3 id="示例-v2">示例</h3>
<h4 id="writerec-c">writerec.c</h4>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* writerec.c */</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> record {</div><div class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> record <span class="built_in">array</span>[<span class="number">2</span>] = { {<span class="string">"Ken"</span>, <span class="number">24</span>}, {<span class="string">"Knuth"</span>, <span class="number">28</span>} };</div><div class="line">    FILE *fp = fopen(<span class="string">"recfile"</span>, <span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span> (fp == NULL) {</div><div class="line">        perror(<span class="string">"Open file recfile"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">    fwrite(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> record), <span class="number">2</span>, fp);</div><div class="line">    fclose(fp);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="readrec-c">readrec.c</h4>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* readrec.c */</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> record {</div><div class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">struct</span> record <span class="built_in">array</span>[<span class="number">2</span>];</div><div class="line">    FILE *fp = fopen(<span class="string">"recfile"</span>, <span class="string">"r"</span>);</div><div class="line">    <span class="keyword">if</span> (fp == NULL) {</div><div class="line">        perror(<span class="string">"Open file recfile"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">    fread(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> record), <span class="number">2</span>, fp);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Name1: %s\tAge1: %d\n"</span>, <span class="built_in">array</span>[<span class="number">0</span>].name, <span class="built_in">array</span>[<span class="number">0</span>].age);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Name2: %s\tAge2: %d\n"</span>, <span class="built_in">array</span>[<span class="number">1</span>].name, <span class="built_in">array</span>[<span class="number">1</span>].age);</div><div class="line">    fclose(fp);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="输出">输出</h4>
<p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ gcc writerec.c -o writerec</div><div class="line">$ gcc readrec.c -o readrec</div><div class="line">$ ./writerec</div><div class="line">$ od -tx1 -tc -Ax recfile </div><div class="line"><span class="number">000000</span> <span class="number">4</span>b <span class="number">65</span> <span class="number">6</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">18</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></div><div class="line">         K   e   n  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span> <span class="number">030</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span></div><div class="line"><span class="number">000010</span> <span class="number">4</span>b <span class="number">6</span>e <span class="number">75</span> <span class="number">74</span> <span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">1</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></div><div class="line">         K   n   u   t   h  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span> <span class="number">034</span>  \<span class="number">0</span>  \<span class="number">0</span>  \<span class="number">0</span></div><div class="line"><span class="number">000020</span></div><div class="line">$ ./readrec </div><div class="line">Name1: Ken	Age1: <span class="number">24</span></div><div class="line">Name2: Knuth	Age2: <span class="number">28</span></div></pre></td></tr></table></figure></p>
<h2 id="文件定位函数">文件定位函数</h2>
<h3 id="fseek">fseek</h3>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fseek(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</div></pre></td></tr></table></figure></p>
<p>fseek函数用于给与stream流相关的文件定位，随后的读写操作将从新位置开始。对于二进制文件，此位置被定位在由 whence 开始的 offset 个字符处。 whence的值可能为：</p>
<ul>
<li><code>SEEK_SET</code>：文件开始处</li>
<li><code>SEEK_CUR</code>：当前位置</li>
<li><code>SEEK_END</code>：文件结束处。</li>
</ul>
<p>offset可正可负，负值表示向前（向文件开头的方向）移动，正值表示向后（向文件末尾的方向）移动，如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸，从原来的文件末尾到fseek移动之后的读写位置之间的字节都是0。</p>
<h4 id="示例-v3">示例</h4>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    FILE* fp;</div><div class="line">    <span class="keyword">if</span> ( (fp = fopen(<span class="string">"textfile"</span>,<span class="string">"r+"</span>)) == NULL) {</div><div class="line">        perror(<span class="string">"Open file textfile"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (fseek(fp, <span class="number">10</span>, SEEK_SET) != <span class="number">0</span>) {</div><div class="line">        perror(<span class="string">"Seek file textfile"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">    fputc(<span class="string">'K'</span>, fp);</div><div class="line">    fclose(fp);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="ftell">ftell</h3>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> ftell(FILE *stream)</div></pre></td></tr></table></figure></p>
<p>ftell 函数用于返回与 stream 流相关的文件的当前位置。在出错时返回 -1L。</p>
<h3 id="rewind">rewind</h3>
<p>rewind(fp)函数等价于 fseek(fp，0L，SEEK_SET) 与 clearerr(fp) 这两个函数顺序执行的效果。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> rewind(FILE *stream)</div></pre></td></tr></table></figure></p>
<h3 id="fgetpos">fgetpos</h3>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fgetpos(FILE *stream， fpos_t *ptr)</div></pre></td></tr></table></figure></p>
<p>fgetpos函数用于把 stream流的当前位置记录在 *ptr中，供随后的 fsetpos 函数调用时使用。若出错则返回一个非 0 值。</p>
<h3 id="fsetpos">fsetpos</h3>
<p>fsetpos函数用于将流 stream 的位置定位在 ptr 所指向的位置。 * ptr的值是在函数 fgetpos 调用时记录下来的。若出错则返回一个非 0 值。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fsetpos(FILE *stream， <span class="keyword">const</span> fpos_t *ptr)</div></pre></td></tr></table></figure></p>
<h2 id="错误处理">错误处理</h2>
<p>当发生错误或到达文件末尾时，标准库中的许多函数将设置状态指示符。这些状态指示符可被显式地设置和测试。另外，很多系统函数在错误返回时将错误原因记录在libc定义的全局变量errno中，每种错误原因对应一个错误码。请查阅errno(3)的Man Page了解各种错误码，errno在头文件errno.h中声明，是一个整型变量，所有错误码都是正整数。</p>
<h3 id="clearerr">clearerr</h3>
<p>clearerr 函数用于清除与流 stream 相关的文件结束指示符和错误指示符。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> clearerr(FILE *stream)</div></pre></td></tr></table></figure></p>
<h3 id="feof">feof</h3>
<p>feof函数用于在与stream流相关的文件结束指示符被设置时返回一个非0值。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> feof(FILE *stream)</div></pre></td></tr></table></figure></p>
<h3 id="ferror">ferror</h3>
<p>ferror函数用于在与stream相关的文件出错指示符被设置时返回一个非0值。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ferror(FILE *stream)</div></pre></td></tr></table></figure></p>
<h3 id="perror">perror</h3>
<p>perror(s) 函数用于输出字符串 s 以及与全局变量 errno 中的整数值相对应的出错信息，具体出错信息的内容依赖于实现。该函数的功能类似于 <code>fprintf(stderr, &quot;%s: %s\n&quot;, s, &quot;出错信息&quot;)</code></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> perror(<span class="keyword">const</span> <span class="keyword">char</span> *s)</div></pre></td></tr></table></figure></p>
<p>如果在程序中打印错误信息时直接打印errno变量，打印出来的只是一个整数值，仍然看不出是什么错误。比较好的办法是用perror或strerror函数将errno解释成字符串再打印。</p>
<h4 id="示例-v4">示例</h4>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">    FILE *fp = fopen(<span class="string">"abcde"</span>, <span class="string">"r"</span>);</div><div class="line">    <span class="keyword">if</span> (fp == NULL) {</div><div class="line">        perror(<span class="string">"Open file abcde"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="说明">说明</h4>
<p>如果文件abcde不存在，fopen返回-1并设置errno为ENOENT，紧接着perror函数读取errno的值，将ENOENT解释成字符串No such file or directory并打印，最后打印的结果是Open file abcde: No such file or directory。虽然perror可以打印出错误原因，传给perror的字符串参数仍然应该提供一些额外的信息，以便在看到错误信息时能够很快定位是程序中哪里出了错，如果在程序中有很多个fopen调用，每个fopen打开不同的文件，那么在每个fopen的错误处理中打印文件名就很有帮助。</p>
<p><div class="alert alert-error"><i class="fa fa-bug"></i>  <p>errno是一个全局变量，很多系统函数都会改变它，所以<strong>一个系统函数错误返回后应该马上检查errno，在检查errno之前不能再调用其它系统函数</strong>。</p>
</div></p>


		<!-- pagination -->
		<div>
		<center>
		<div class="pagination">
<ul class="pagination">
	
	
	
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
			
			
		
	
	    
	
	    
	
	    
	
	    
			
			
			
	    
	
	    
	
	    
			
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
			
			
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
			
			
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	
		<li class="prev"><a data-pjax href="/wiki/c-pointer.html" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
	
	<li><a data-pjax href="/wiki"><i class="fa fa-tasks"></i>Wiki</a></li>
	
		<li class="next"><a data-pjax href="/wiki/c-pre.html" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

	    </center>
		</div>
				
		<!-- toc -->
		
   	<script type="text/javascript">
		jQuery(document).ready(function() {
		
 		   generateWikiTOC('.note', '.toc',  2 , 2 );
		
		});
	</script>



				
		<!-- comment -->
		
<section id="comment">
    <h2 class="title">Comments</h2>
	
	 <div id="comment-thread"></div>
	 <div id="loading-spin"></div>
	 <script type="text/javascript">
	   getComments({
		       type: "github",
	           user: "wzpan",
	           repo: "wzpan.github.io",
			   client_id: "1eb35434de75c06a513f",
			   client_secret: "6e4193f8ecd619cdfac2b1aa16b3663fe18d2e90",
			   no_comment: "暂时还没有留言呢，点击下面的按钮去留言吧！",
			   go_to_comment: "去留言",
			   btn_class: "btn btn-primary",
			   no_issue: "no_issue",
			   issue_title: "输入输出",
			   issue_id: "undefined",
			   comments_target: "#comment-thread" ? "#comment-thread" : "#comment-thread",
			   loading_target: "undefined"
			   });
	 </script>
	
</section>


		

	</div> <!-- span9/span12 -->
</div><!-- row-fluid post-full -->

	</div>	
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 Joseph Pan
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and 
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254469760'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1254469760' type='text/javascript'%3E%3C/script%3E"));</script>
. 
    <small>
     <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"><img title="知识共享许可协议" style="border-width: 0px; vertical-align: middle; display: inline; " src="/images/license.png"></a>
    </small>
</p>
 </footer>
</div> <!-- container-narrow -->


<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/dist/jquery.imagesloaded.min.js"></script>


<script src="/dist/gallery.min.js"></script>
<script src="/dist/bootstrap.min.js"></script>
<script src="/dist/jquery.tableofcontents.min.js"></script>
<script src="/dist/tocgenerator.min.js"></script>
<script src="/dist/require.min.js"></script>
<script src="/dist/main.min.js"></script>


<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','ney3Rb77vMaWT2KUKFyt');
</script>


</body>
</html>
