<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构 | HaHack</title>
  <meta name="author" content="Joseph Pan">
  
  <meta name="description" content="“Algorithm + Data Structures = Programs” - Niklaus Wirth

栈和队列
栈和队列都是动态集合，且在其上进行 DELETE 操作所移除的元素都是预先设定的。

在栈（stack）中，被删除的是最近插入的元素；栈实现的是一种后进先出（last-in ">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="数据结构"/>
  <meta property="og:site_name" content="HaHack"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/images/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="HaHack" type="application/atom+xml">
  
  <link rel="stylesheet" href="/dist/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/bootstrap-responsive.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/font-awesome.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/style.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/highlight.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/sidenav.min.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/dist/responsive.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/bubble.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/google-fonts.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/nprogress.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/dist/comment.min.css" media="screen" type="text/css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <!--[if lte IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

<!--  -->
<!--     <link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow|PT+Sans:400,400italic,700,700italic|Droid+Serif:400,400italic' rel='stylesheet' type='text/css'> -->
<!--     <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'> -->
<!--  -->
  
<script src="/dist/jquery-2.0.3.min.js"></script>


    <script src="/dist/videoGFW.min.js"></script>
	
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-41569408-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;

ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';

var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

	


    <link rel="stylesheet" href="/dist/highlight-default.min.css" media="screen" type="text/css">
    
    <script src="/dist/comment.min.js"></script>
    <script src="/dist/marked.min.js"></script>
    
    <script src="/dist/highlight.min.js"></script>
    <script src="/dist/timeago.min.js"></script>
	<script src="/dist/spin.min.js"></script>


</head>


<body data-spy="scroll" data-target=".toc">  
  <header id="header" class="inner"><div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
            <a data-pjax class="brand" href="/">HaHack</a>
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <div class="nav-collapse collapse">
            <ul class="nav">				
			    
				   <li><a data-pjax href="/archive" title="所有文章归档"><i class="fa fa-archive"></i>Archive</a></li>
    			
				   <li><a data-pjax href="/categories" title="所有文章分类"><i class="fa fa-folder"></i>Categories</a></li>
    			
				   <li><a data-pjax href="/tags" title="所有文章标签"><i class="fa fa-tags"></i>Tags</a></li>
    			
				
				<li class="divider-vertical"></li>
			   	<li><a data-pjax href="/wiki" title="我的笔记库"><i class="fa fa-tasks"></i>wiki</a></li>				   
				
            </ul>			
			<ul class="nav navright">
				<li class="dropdown works">
				<a data-pjax href="#" title="作品集" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-th-large"></i>Works <b class="caret"></b></a>
                <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">				
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/wukong-robot" title="wukong-robot 是一个简单、灵活、优雅的中文语音对话机器人。"><i class="fab fa-github"></i>wukong-robot</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/dingdang-robot/dingdang-robot" title="叮当是一款可以工作在 Raspberry Pi 上的中文语音对话机器人/智能音箱项目。"><i class="fab fa-github"></i>dingdang-robot</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/comment-js" title="纯JS实现的静态站点评论系统，使用 Github/OSChina 作为 backend。"><i class="fab fa-github"></i>comment.js</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/qtevm" title="首个完整的 C++ 开源实现，能同时放大动作变化和颜色变化"><i class="fab fa-github"></i>QtEVM</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/hexo-series" title="为 Hexo 写的一系列主题/工具/插件"><i class="fab fa-github"></i>hexo-series</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/scnu/scnuthesis" title="符合华南师范大学硕士/博士学位论文格式要求的LaTeX模板。"><i class="fab fa-github"></i>SCNUThesis</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/slides" title="一些幻灯片作品"><i class="fab fa-github"></i>Slides</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://hahack.com/codes/fcevm/" title="硕士毕业论文"><i class="fab fa-github"></i>Dissertation</a></li>
				
                </ul>                
				</li>
                <li class="dropdown works">
				<a data-pjax href="#" title="课程" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-video"></i>Courses <b class="caret"></b></a>
                <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">
                
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/list/python%20next%20潘伟洲" title="Python 从入门到实践系列"><i class="fa fa-video"></i>Python</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/326820" title="微信小游戏入门与实战"><i class="fa fa-video"></i>minigame</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/350627" title="使用Cocos Creator开发微信小游戏《2048》"><i class="fa fa-video"></i>2048</a></li>
				
                </ul>                
				</li>                
				<li class="dropdown">
				<a data-pjax href="#" title="订阅本站" class="dropdown-toggle" data-toggle="dropdown"><i class="fa fa-rss"></i>Subscribe <b class="caret"></b></a>
                                <ul class="dropdown-menu" role="menu" aria-labelledby="drop2">
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="/atom.xml" title="使用 RSS 阅读器订阅 HaHack"><i class="fa fa-rss-square"></i>RSS</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="/wechat.html" title="订阅 HaHack 的公众平台"><i class="fa fa-qrcode"></i>WeChat</a></li>
				
				   <li role="presentation"><a role="menuitem" tabindex="-1" href="http://toutiao.io/u/147640" title=""><i class="fa fa-align-justify"></i>Toutiao</a></li>
				
                	        </ul>
				</li>
				
				<li><a data-pjax href="/about" title="关于我"><i class="fa fa-user"></i>About</a></li>				   				
   					  
            </ul>
            </div> <!-- nav-collapse collapse -->
        </div> <!-- container -->
     </div> <!-- navbar-inner -->
</div> <!-- navbar navbar-inverse -->
</header>
  <div class="container" id="container">
  	<div class="content">
    	 

	
		<div class="page-header">		
			<h1> 数据结构</h1>
		</div>    
	



<div class="row-fluid wiki">
	<!-- span -->
    
        <div class="span3 toc"></div>
        <div class="span9 note">
    

	

		<!-- content -->
		<blockquote>
<p>“Algorithm + Data Structures = Programs” - Niklaus Wirth</p>
</blockquote>
<h2 id="栈和队列">栈和队列</h2>
<p>栈和队列都是动态集合，且在其上进行 DELETE 操作所移除的元素都是预先设定的。</p>
<ul>
<li>在栈（stack）中，被删除的是最近插入的元素；栈实现的是一种<strong>后进先出</strong>（last-in first out, LIFO）策略。</li>
<li>在队列（queue）中，被删去的总是在集合中存在时间最长的那个元素；队列实现的是一种<strong>先进先出</strong>（First-in first out, FIFO）策略。</li>
</ul>
<h3 id="栈">栈</h3>
<p>可以用一个数组 \(S[1..n]\) 来实现一个最多可容纳 \(n\) 个元素的栈。该数组有一个属性 S.top，指向最新插入的元素。栈中包含的元素为 \(S[1..S.top]\)，其中 \(S[1]\) 是栈底元素，而 \(S[S.top]\) 是栈顶元素。</p>
<p><img src="/images/algorithms-data-structure/stack.png" alt="栈S的数组实现"></p>
<h4 id="实现">实现</h4>
<p>C语言实现的倒序打印：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">512</span>];</div><div class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> isEmpty()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> pop()</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (isEmpty())</div><div class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>[top--];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> push(<span class="keyword">int</span> num)</div><div class="line">{</div><div class="line">    <span class="built_in">stack</span>[++top] = num;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) {</div><div class="line">        push(i);</div><div class="line">    }</div><div class="line">    <span class="keyword">while</span>(!isEmpty()){</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pop());</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h2 id="链表">链表</h2>
<p>链表（linked list）是一种这样的数据结构，其中的各对象按线性顺序排列。数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法，并且可以支持大多数动态集合的操作。</p>
<p>每个链表有一个头指针（head），通过头指针可以找到第一个节点，每个节点都可以通过指针域找到它的后继（next），最后一个节点的指针域为NULL，表示没有后继。数组在内存中是连续存放的，而链表在内存中的布局是不规则的，我们知道访问某个数组元素 b[n] 时可以通过 基地址+n×每个元素的字节数 得到它地址，或者说数组支持随机访问，而链表是不支持随机访问的，只能通过前一个元素的指针域得知后一个元素的地址，因此只能从头指针开始顺序访问各节点。</p>
<h3 id="定义">定义</h3>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node{</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    Node *next;</div><div class="line">}Node, *<span class="built_in">list</span>;</div></pre></td></tr></table></figure></p>
<h3 id="创建结点">创建结点</h3>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Node* createNode(<span class="keyword">int</span> data)</div><div class="line">{</div><div class="line">    Node *p = <span class="keyword">new</span> Node;</div><div class="line">    p-&gt;data = data;</div><div class="line">    p-&gt;next = NULL;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="删除结点">删除结点</h3>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> freeNode(Node *p)</div><div class="line">{</div><div class="line">    <span class="keyword">delete</span> p;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="遍历所有结点">遍历所有结点</h3>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> visit(Node *p)</div><div class="line">{</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);    </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> traverse(Node *head, <span class="keyword">void</span> (*visit)(Node *))</div><div class="line">{</div><div class="line">    <span class="keyword">for</span> (Node *p = head; p; p = p-&gt;next){</div><div class="line">        visit(p);        </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="查找结点">查找结点</h3>
<h4 id="查找第一个值为-key-的结点">查找第一个值为 key 的结点</h4>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Node* searchNode(Node *head, <span class="keyword">int</span> key)</div><div class="line">{</div><div class="line">    <span class="keyword">for</span>(Node *p = head; p; p = p-&gt;next){</div><div class="line">        <span class="keyword">if</span> (p-&gt;data == key) <span class="keyword">return</span> p;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="查找第-pos-个位置的结点">查找第 pos 个位置的结点</h4>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Node* accessNode (Node *head, <span class="keyword">int</span> pos){</div><div class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) {</div><div class="line">        perror(<span class="string">"Incorrect position!"</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) <span class="keyword">return</span> head;</div><div class="line">    Node *p = head;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pos && p; i++){</div><div class="line">        p = p-&gt;next;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (i == pos) <span class="keyword">return</span> p;</div><div class="line">    <span class="keyword">else</span> {</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Incorrect position!"</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }    </div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="插入结点">插入结点</h3>
<h4 id="头插入">头插入</h4>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Node* insertHead(Node *head, Node *nd){</div><div class="line">    nd-&gt;next = head;</div><div class="line">    head = nd;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div><div class="line"></div><div class="line">Node* insertHead(Node *head, <span class="keyword">int</span> data){</div><div class="line">    Node *nd = createNode(data);</div><div class="line">    head = insertHead(head, nd);</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="尾插入">尾插入</h4>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Node* insertTail(Node *head, Node *nd){</div><div class="line">    <span class="keyword">if</span> (!head){</div><div class="line">        head = nd;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        Node *p;</div><div class="line">        <span class="keyword">for</span> (p = head; p-&gt;next; p = p-&gt;next);</div><div class="line">        p-&gt;next = nd;</div><div class="line">        p = nd;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">Node* insertTail(Node *head, <span class="keyword">int</span> data){</div><div class="line">    Node *nd = createNode(data);</div><div class="line">    head = insertTail(head, nd);</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="任意位置插入">任意位置插入</h4>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Node* insertNode(Node *head, <span class="keyword">int</span> pos, Node *nd){</div><div class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) {</div><div class="line">        perror(<span class="string">"Incorrect position!"</span>);</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span> && !head){</div><div class="line">        head = nd;</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line">    Node *p = accessNode(head, pos-<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (p != NULL){</div><div class="line">        nd-&gt;next = p-&gt;next;</div><div class="line">        p-&gt;next = nd;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        perror(<span class="string">"Incorrect position!"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div><div class="line"></div><div class="line">Node* insertNode(Node *head, <span class="keyword">int</span> pos, <span class="keyword">int</span> data){</div><div class="line">    Node *nd = createNode(data);</div><div class="line">    insertNode(head, pos, nd);</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="删除结点-v2">删除结点</h3>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Node* deleteNode(Node *head, <span class="keyword">int</span> pos)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>){</div><div class="line">        perror(<span class="string">"Invalidate position!"</span>);</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!head){</div><div class="line">        perror(<span class="string">"Link is empty!"</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line">    Node *p;</div><div class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>){</div><div class="line">        p = head;</div><div class="line">        head = head-&gt;next;</div><div class="line">        freeNode(p);</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    }</div><div class="line">    p = accessNode(head, pos-<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (p != NULL && p-&gt;next != NULL){</div><div class="line">        Node *item = p-&gt;next;</div><div class="line">        p-&gt;next = item-&gt;next;</div><div class="line">        freeNode(item);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        perror(<span class="string">"Invalidate position!"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="用数组初始化一个链表">用数组初始化一个链表</h4>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Node* init(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</div><div class="line">{</div><div class="line">    Node *head = NULL;</div><div class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>){</div><div class="line">        perror(<span class="string">"Invalidate length!"</span>);</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    }</div><div class="line">    Node *p;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i){</div><div class="line">        <span class="comment">//or: insertNode(i, a[i]);</span></div><div class="line">        <span class="comment">//or: insertTail(a[i]);</span></div><div class="line">        Node *nd = createNode(a[i]);</div><div class="line">        <span class="keyword">if</span> (NULL == head){</div><div class="line">            head = p = nd;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">        p-&gt;next = nd;</div><div class="line">        p = nd;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="清空一个链表">清空一个链表</h3>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Node* destroy(Node *head)</div><div class="line">{</div><div class="line">    Node *p = head;</div><div class="line">    Node *q;</div><div class="line">    <span class="keyword">while</span>(p){</div><div class="line">        q = p;</div><div class="line">        p = p-&gt;next;</div><div class="line">        freeNode(q);</div><div class="line">    }</div><div class="line">    head = NULL;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="求链表长">求链表长</h3>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> length(Node *head)</div><div class="line">{</div><div class="line">    Node *p = head;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; p; ++i){</div><div class="line">        p = p-&gt;next;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="获取链表中间结点">获取链表中间结点</h3>
<p>用一个快指针和一个慢指针实现。慢指针移动的速度是快指针的一半，当快指针走完链表时，输出慢指针。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Node* accessMid(Node *head)</div><div class="line">{</div><div class="line">    Node *slow = head;</div><div class="line">    Node *fast = head;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(fast){</div><div class="line">        <span class="keyword">if</span> (j &lt; i/<span class="number">2</span>){</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            ++j;</div><div class="line">        }</div><div class="line">        fast = fast-&gt;next;</div><div class="line">        ++i;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="单链表排序">单链表排序</h3>
<p>最简单的可以使用选择排序实现：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Node* selectionSort(Node *head)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</div><div class="line"></div><div class="line">    Node *p, *q, *min;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="keyword">for</span> (p = head; p; p = p-&gt;next){</div><div class="line">        min = p;</div><div class="line">        <span class="keyword">for</span> (q = p; q; q = q-&gt;next)</div><div class="line">            <span class="keyword">if</span> (q-&gt;data &lt; min-&gt;data) min = q;</div><div class="line">        <span class="keyword">if</span> (min != p){</div><div class="line">            t = min-&gt;data;</div><div class="line">            min-&gt;data = p-&gt;data;</div><div class="line">            p-&gt;data = t;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="将单链表反转">将单链表反转</h3>
<p>从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n）。参考代码如下：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 反转单链表  </span></div><div class="line">Node * reverseList(Node * pHead)  </div><div class="line">{  </div><div class="line">    <span class="comment">// 如果链表为空或只有一个结点，无需反转，直接返回原链表头指针  </span></div><div class="line">    <span class="keyword">if</span>(pHead == NULL || pHead-&gt;next == NULL)    </div><div class="line">        <span class="keyword">return</span> pHead;  </div><div class="line">  </div><div class="line">    Node *pReversedHead = NULL; <span class="comment">// 反转后的新链表头指针，初始为NULL  </span></div><div class="line">    Node *pCurrent = pHead;  </div><div class="line">    <span class="keyword">while</span>(pCurrent != NULL)  </div><div class="line">    {  </div><div class="line">        Node *pTemp = pCurrent;  </div><div class="line">        pCurrent = pCurrent-&gt;next;  </div><div class="line">        pTemp-&gt;next = pReversedHead; <span class="comment">// 将当前结点摘下，插入新链表的最前端  </span></div><div class="line">        pReversedHead = pTemp;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">return</span> pReversedHead;  </div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="逆序打印单链表">逆序打印单链表</h3>
<p>对于这种颠倒顺序的问题，我们应该就会想到栈，后进先出。所以，这一题要么自己使用栈，要么让系统使用栈，也就是递归。注意链表为空的情况。时间复杂度为O（n）。参考代码如下：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从尾到头打印链表，使用递归  </span></div><div class="line"><span class="keyword">void</span> reversePrint(Node *pHead)  </div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pHead == NULL)</div><div class="line">    {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span></div><div class="line">    {</div><div class="line">        reversePrint(pHead-&gt;next);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;data);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="判断是否存在环">判断是否存在环</h3>
<p>用一个快指针和一个慢指针实现。慢指针每次移动一步，快指针就移动两步。如果两个指针能够相遇，证明存在环。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> isLoop(Node *head)</div><div class="line">{</div><div class="line">    Node *slow = head, *fast = head;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (NULL == head || NULL == head-&gt;next) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">do</span> {</div><div class="line">        fast = fast-&gt;next-&gt;next;</div><div class="line">        slow = slow-&gt;next;        </div><div class="line">    }</div><div class="line">    <span class="keyword">while</span> (fast && fast-&gt;next && fast!=slow);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (fast == slow){        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="找出环的起点">找出环的起点</h3>
<p>当快指针和慢指针相遇后，慢指针返回链表头，快指针从相遇点开始，两个指针重新恢复一次一步的速度移动。如果再次相遇，则该相遇的地点即为环的起点。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Node* loopstart(Node *head)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (NULL == head || NULL == head-&gt;next) <span class="keyword">return</span> NULL;</div><div class="line">    Node *slow = head, *fast = head;</div><div class="line">    <span class="keyword">while</span>(fast && fast-&gt;next){</div><div class="line">        fast = fast-&gt;next-&gt;next;</div><div class="line">        slow = slow-&gt;next;</div><div class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span>(!fast || !fast-&gt;next) <span class="keyword">return</span> NULL;</div><div class="line">    slow = head;</div><div class="line">    <span class="keyword">while</span>(fast != slow){</div><div class="line">        fast = fast-&gt;next;</div><div class="line">        slow = slow-&gt;next;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> fast;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="判断两个单链表是否相交">判断两个单链表是否相交</h3>
<p>如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指针保存最后一个节点地址，空间复杂度为 O(1)。参考代码如下：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> isIntersected(Node *pHead1, Node *pHead2)  </div><div class="line">{  </div><div class="line">    <span class="keyword">if</span>(pHead1 == NULL || pHead2 == NULL)  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line"></div><div class="line">    Node* pTail1 = pHead1;  </div><div class="line">    <span class="keyword">while</span>(pTail1-&gt;next != NULL)  </div><div class="line">        pTail1 = pTail1-&gt;next;  </div><div class="line"></div><div class="line">    Node* pTail2 = pHead2;  </div><div class="line">    <span class="keyword">while</span>(pTail2-&gt;next != NULL)  </div><div class="line">        pTail2 = pTail2-&gt;next;  </div><div class="line">    <span class="keyword">return</span> pTail1 == pTail2;  </div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="求两个单链表相交的第一个节点">求两个单链表相交的第一个节点</h3>
<ol>
<li>对第一个链表遍历，计算长度len1，同时保存最后一个节点的地址。</li>
<li>对第二个链表遍历，计算长度len2，同时检查最后一个节点是否和第一个链表的最后一个节点相同，若不相同，不相交，结束。</li>
</ol>
<p>两个链表均从头节点开始，假设len1大于len2，那么将第一个链表先遍历len1-len2个节点，此时两个链表当前节点到第一个相交节点的距离就相等了，然后一起向后遍历，直到两个节点的地址相同。</p>
<p>时间复杂度，O(len1+len2)。参考代码如下：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">Node* GetFirstCommonNode(Node *pHead1, Node * pHead2)  </div><div class="line">{  </div><div class="line">    <span class="keyword">if</span>(pHead1 == NULL || pHead2 == NULL)  </div><div class="line">        <span class="keyword">return</span> NULL;  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> len1 = <span class="number">1</span>;  </div><div class="line">    Node * pTail1 = pHead1;  </div><div class="line">    <span class="keyword">while</span>(pTail1-&gt;next != NULL)  </div><div class="line">    {  </div><div class="line">        pTail1 = pTail1-&gt;next;  </div><div class="line">        len1++;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> len2 = <span class="number">1</span>;  </div><div class="line">    Node * pTail2 = pHead2;  </div><div class="line">    <span class="keyword">while</span>(pTail2-&gt;next != NULL)  </div><div class="line">    {  </div><div class="line">        pTail2 = pTail2-&gt;next;  </div><div class="line">        len2++;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span>(pTail1 != pTail2) <span class="comment">// 不相交直接返回NULL  </span></div><div class="line">        <span class="keyword">return</span> NULL;  </div><div class="line">  </div><div class="line">    Node *pNode1 = pHead1;  </div><div class="line">    Node *pNode2 = pHead2;  </div><div class="line">    <span class="comment">// 先对齐两个链表的当前结点，使之到尾节点的距离相等  </span></div><div class="line">    <span class="keyword">if</span>(len1 &gt; len2)  </div><div class="line">    {  </div><div class="line">        <span class="keyword">int</span> k = len1 - len2;  </div><div class="line">        <span class="keyword">while</span>(k--)  </div><div class="line">            pNode1 = pNode1-&gt;next;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    {  </div><div class="line">        <span class="keyword">int</span> k = len2 - len1;  </div><div class="line">        <span class="keyword">while</span>(k--)  </div><div class="line">            pNode2 = pNode2-&gt;next;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">while</span>(pNode1 != pNode2)  </div><div class="line">    {  </div><div class="line">        pNode1 = pNode1-&gt;next;  </div><div class="line">        pNode2 = pNode2-&gt;next;  </div><div class="line">    }  </div><div class="line">        <span class="keyword">return</span> pNode1;  </div><div class="line">}</div></pre></td></tr></table></figure></p>
<h2 id="二叉树">二叉树</h2>
<p>二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p>
<h3 id="节点定义">节点定义</h3>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Node</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    Node* lchild;</div><div class="line">    Node* rchild;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<p>有些实现还会带上父节点：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Node</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    Node* lchild;</div><div class="line">    Node* rchild;</div><div class="line">    Node* parent;</div><div class="line">};</div></pre></td></tr></table></figure></p>
<h3 id="求节点数">求节点数</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，节点个数为0</li>
<li>如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> getNodeNum(Node *pRoot)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> getNodeNum(pRoot-&gt;lchild) + getNodeNum(pRoot-&gt;rchild) + <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="求树高">求树高</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，二叉树的树高为0</li>
<li>如果二叉树不为空，二叉树的树高 = max(左子树树高， 右子树树高) + 1</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> getDepth(Node *pRoot){</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ld = getDepth(pRoot-&gt;lchild);</div><div class="line">    <span class="keyword">int</span> rd = getDepth(pRoot-&gt;rchild);</div><div class="line">    <span class="keyword">return</span> ld &gt; rd ? (ld + <span class="number">1</span>) : (rd + <span class="number">1</span>);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="遍历">遍历</h3>
<h4 id="前序遍历">前序遍历</h4>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> preOrderTraverse(Node *pRoot)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL) <span class="keyword">return</span>;</div><div class="line">    visit(pRoot); <span class="comment">// 访问根节点  </span></div><div class="line">    preOrderTraverse(pRoot-&gt;lchild); <span class="comment">// 前序遍历左子树  </span></div><div class="line">    preOrderTraverse(pRoot-&gt;rchild); <span class="comment">// 前序遍历右子树  </span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="中序遍历">中序遍历</h4>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，中序遍历左子树，访问根节点，中序遍历右子树</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> inOrderTraverse(Node *pRoot)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL) <span class="keyword">return</span>;</div><div class="line">    inOrderTraverse(pRoot-&gt;lchild); <span class="comment">// 中序遍历左子树  </span></div><div class="line">    visit(pRoot); <span class="comment">// 访问根节点  </span></div><div class="line">    inOrderTraverse(pRoot-&gt;rchild); <span class="comment">// 中序遍历右子树  </span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="后序遍历">后序遍历</h4>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> postOrderTraverse(Node *pRoot)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL) <span class="keyword">return</span>;</div><div class="line">    postOrderTraverse(pRoot-&gt;lchild); <span class="comment">// 后序遍历左子树  </span></div><div class="line">    postOrderTraverse(pRoot-&gt;rchild); <span class="comment">// 后序遍历右子树  </span></div><div class="line">    visit(pRoot); <span class="comment">// 访问根节点</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="层序遍历">层序遍历</h4>
<p>相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> levelTraverse(Node *pRoot)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL) <span class="keyword">return</span>;</div><div class="line">    <span class="stl_container"><span class="built_in">queue</span>&lt;Node*&gt;</span> q;</div><div class="line">    q.push(pRoot);</div><div class="line">    <span class="keyword">while</span>(!q.empty())</div><div class="line">    {</div><div class="line">        Node *pNode = q.front();</div><div class="line">        q.pop();</div><div class="line">        visit(pNode); <span class="comment">// 访问节点</span></div><div class="line">        <span class="keyword">if</span>(pNode-&gt;lchild != NULL)</div><div class="line">            q.push(pNode-&gt;lchild);</div><div class="line">        <span class="keyword">if</span>(pNode-&gt;rchild != NULL)</div><div class="line">            q.push(pNode-&gt;rchild);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="求二叉树第k层的节点个数">求二叉树第K层的节点个数</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空或者k&lt;1返回0</li>
<li>如果二叉树不为空并且k==1，返回1</li>
<li>如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> getNodeNumKthLevel(Node *pRoot, <span class="keyword">int</span> k)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numLeft = getNodeNumKthLevel(pRoot-&gt;lchild, k-<span class="number">1</span>); <span class="comment">// 左子树中k-1层的节点个数  </span></div><div class="line">    <span class="keyword">int</span> numRight = getNodeNumKthLevel(pRoot-&gt;rchild, k-<span class="number">1</span>); <span class="comment">// 右子树中k-1层的节点个数  </span></div><div class="line">    <span class="keyword">return</span> (numLeft + numRight);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="求二叉树中叶子节点的个数">求二叉树中叶子节点的个数</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回0</li>
<li>如果二叉树不为空且左右子树为空，返回1</li>
<li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> getLeafNodeNum(Node * pRoot)  </div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL)  </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span>(pRoot-&gt;lchild == NULL && pRoot-&gt;rchild == NULL)  </div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> numLeft = getLeafNodeNum(pRoot-&gt;lchild); <span class="comment">// 左子树中叶节点的个数  </span></div><div class="line">    <span class="keyword">int</span> numRight = getLeafNodeNum(pRoot-&gt;rchild); <span class="comment">// 右子树中叶节点的个数  </span></div><div class="line">    <span class="keyword">return</span> (numLeft + numRight);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="判断二叉树是不是平衡二叉树">判断二叉树是不是平衡二叉树</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回真</li>
<li>如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> isAVL(Node *pRoot, <span class="keyword">int</span> &height)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL) <span class="comment">// 空树，返回真</span></div><div class="line">    {</div><div class="line">        height = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">int</span> heightLeft;</div><div class="line">    <span class="keyword">bool</span> resultLeft = isAVL(pRoot-&gt;lchild, heightLeft);</div><div class="line">    <span class="keyword">int</span> heightRight;</div><div class="line">    <span class="keyword">bool</span> resultRight = isAVL(pRoot-&gt;rchild, heightRighte);</div><div class="line">    <span class="keyword">if</span>(resultLeft && resultRight && <span class="built_in">abs</span>(heightLeft - heightRight) &lt;= <span class="number">1</span>) <span class="comment">// 左子树和右子树都是AVL，并且高度相差不大于1，返回真  </span></div><div class="line">    {</div><div class="line">        height = max(heightLeft, heightRight) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        height = max(heightLeft, heightRight) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="求二叉树的镜像">求二叉树的镜像</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回空</li>
<li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左子树和右子树</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Node* mirror(Node *pRoot)</div><div class="line">{  </div><div class="line">    <span class="keyword">if</span>(pRoot == NULL) <span class="keyword">return</span> NULL;</div><div class="line">    Node *pLeft = mirror(pRoot-&gt;lchild); <span class="comment">// 求左子树镜像</span></div><div class="line">    Node *pRight = mirror(pRoot-&gt;rchild); <span class="comment">// 求右子树镜像</span></div><div class="line">    <span class="comment">// 交换左子树和右子树</span></div><div class="line">    pRoot-&gt;lchild = pRight;</div><div class="line">    pRoot-&gt;rchild = pLeft;</div><div class="line">    <span class="keyword">return</span> pRoot;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="由前序遍历序列和中序遍历序列重建二叉树">由前序遍历序列和中序遍历序列重建二叉树</h3>
<p>二叉树前序遍历序列中，第一个元素总是树的根节点的值。中序遍历序列中，左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。</p>
<p>递归解法：</p>
<ol>
<li>如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL。</li>
<li>创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树。</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Node* rebuildBinaryTree(<span class="keyword">int</span>* pPreOrder, <span class="keyword">int</span>* pInOrder, <span class="keyword">int</span> nodeNum)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pPreOrder == NULL || pInOrder == NULL || nodeNum &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    Node *pRoot = <span class="keyword">new</span> Node;</div><div class="line">    <span class="comment">// 前序遍历的第一个数据就是根节点数据  </span></div><div class="line">    pRoot-&gt;data = pPreOrder[<span class="number">0</span>]; </div><div class="line">    pRoot-&gt;lchild = NULL;</div><div class="line">    pRoot-&gt;rchild = NULL;</div><div class="line">    <span class="comment">// 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树</span></div><div class="line">    <span class="keyword">int</span> rootPositionInOrder = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++)</div><div class="line">        <span class="keyword">if</span>(pInOrder[i] == pRoot-&gt;data)</div><div class="line">        {</div><div class="line">            rootPositionInOrder = i;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    <span class="keyword">if</span>(rootPositionInOrder == -<span class="number">1</span>)</div><div class="line">    {</div><div class="line">        <span class="keyword">throw</span> std::exception(<span class="string">"Invalid input."</span>);</div><div class="line">    }</div><div class="line">    <span class="comment">// 重建左子树  </span></div><div class="line">    <span class="keyword">int</span> nodeNumLeft = rootPositionInOrder;</div><div class="line">    <span class="keyword">int</span> * pPreOrderLeft = pPreOrder + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> * pInOrderLeft = pInOrder;</div><div class="line">    pRoot-&gt;lchild = rebuildBinaryTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);</div><div class="line">    <span class="comment">// 重建右子树  </span></div><div class="line">    <span class="keyword">int</span> nodeNumRight = nodeNum - nodeNumLeft - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> *pPreOrderRight = pPreOrder + <span class="number">1</span> + nodeNumLeft;</div><div class="line">    <span class="keyword">int</span> *pInOrderRight = pInOrder + nodeNumLeft + <span class="number">1</span>;</div><div class="line">    pRoot-&gt;rchild = rebuildBinaryTree(pPreOrderRight, pInOrderRight, nodeNumRight);</div><div class="line">    <span class="keyword">return</span> pRoot;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但<strong>前序遍历序列和后序遍历序列不能恢复一棵二叉树</strong>，证明略。</p>
<p><div class="alert alert-error"><i class="fa fa-bug"></i>  <p>前序遍历序列和后序遍历序列不能恢复一棵二叉树。</p>
</div></p>
<h3 id="判断二叉树是不是完全二叉树">判断二叉树是不是完全二叉树</h3>
<p>若设二叉树的深度为h，除第 h 层外，其它各层（1～h-1）的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<p>有如下算法：按层次（从上到下，从左到右）遍历二叉树，当遇到一个节点的左子树为空时，则该节点右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> IsCompleteBinaryTree(Node *pRoot)</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="stl_container"><span class="built_in">queue</span>&lt;Node*&gt;</span> q;</div><div class="line">    q.push(pRoot);</div><div class="line">    <span class="keyword">bool</span> mustHaveNoChild = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">bool</span> result = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">while</span>(!q.empty())</div><div class="line">    {</div><div class="line">        Node* pNode = q.front();</div><div class="line">        q.pop();</div><div class="line">        <span class="keyword">if</span>(mustHaveNoChild) <span class="comment">// 已经出现了有空子树的节点了，后面出现的必须为叶节点（左右子树都为空）  </span></div><div class="line">        {</div><div class="line">            <span class="keyword">if</span>(pNode-&gt;lchild != NULL || pNode-&gt;rchild != NULL)</div><div class="line">            {</div><div class="line">                result = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span>  </div><div class="line">        {  </div><div class="line">            <span class="keyword">if</span>(pNode-&gt;lchild != NULL && pNode-&gt;rchild != NULL)  </div><div class="line">            {  </div><div class="line">                q.push(pNode-&gt;lchild);  </div><div class="line">                q.push(pNode-&gt;rchild);  </div><div class="line">            }  </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;lchild != NULL && pNode-&gt;rchild == NULL)  </div><div class="line">            {  </div><div class="line">                mustHaveNoChild = <span class="keyword">true</span>;  </div><div class="line">                q.push(pNode-&gt;lchild);  </div><div class="line">            }  </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;lchild == NULL && pNode-&gt;rchild != NULL)  </div><div class="line">            {  </div><div class="line">                result = <span class="keyword">false</span>;  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            }  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">            {  </div><div class="line">                mustHaveNoChild = <span class="keyword">true</span>;  </div><div class="line">            }  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">    <span class="keyword">return</span> result;  </div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3 id="二叉查找树">二叉查找树</h3>
<p>如果我们给二叉树加一个额外的条件，就可以得到一种被称作二叉查找树(binary search tree)的特殊二叉树。二叉查找树要求：每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大。</p>
<h4 id="插入节点">插入节点</h4>
<p>首先执行查找算法，找出被插结点的父亲结点。</p>
<p>判断被插结点是其父亲结点的左、右儿子。将被插结点作为叶子结点插入。</p>
<p>若二叉树为空。则首先单独生成根结点。</p>
<p>注意：新插入的结点总是叶子结点。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> insertNode(Node* &pRoot, <span class="keyword">int</span> x){</div><div class="line">    <span class="keyword">if</span>(pRoot == NULL){</div><div class="line">        pRoot = <span class="keyword">new</span> Node;</div><div class="line">        pRoot-&gt;lchild = pRoot-&gt;rchild = NULL;</div><div class="line">        pRoot-&gt;data = x;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span>(x &lt; pRoot-&gt;data)</div><div class="line">        insertNode(pRoot-&gt;lchild, x);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        insertNode(pRoot-&gt;rchild, x);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="删除节点">删除节点</h4>
<p>删除某个结点后依然要保持二叉查找树的特性。例子中的删除过程如下：</p>
<ol>
<li>若删除点是叶子结点，则设置其双亲结点的指针为空。</li>
<li>若删除点只有左子树，或只有右子树，则设置其双亲结点的指针指向左子树或右子树。</li>
<li>若删除点的左右子树均不为空，则：
<ul>
<li>查询删除点的右子树的左子树是否为空，若为空，则把删除点的左子树设为删除点的右子树的左子树。</li>
<li>若不为空，则继续查询左子树，直到找到最底层的左子树为止。</li>
</ul>
</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> deleteNode(Node *root, <span class="keyword">int</span> data)  </div><div class="line">{</div><div class="line">    Node p = *root, parent, s;</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (NULL == p) <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (p-&gt;data == data) {</div><div class="line">        <span class="comment">// It's a leaf node</span></div><div class="line">        <span class="keyword">if</span> (!p-&gt;rchild && !p-&gt;lchild) {</div><div class="line">            *root = NULL;</div><div class="line">            <span class="built_in">free</span>(p);</div><div class="line">        }</div><div class="line">        <span class="comment">// the right child is NULL</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;rchild) {</div><div class="line">            *root = p-&gt;lchild;</div><div class="line">            <span class="built_in">free</span>(p);  </div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;lchild) {</div><div class="line">            *root = p-&gt;rchild;</div><div class="line">            <span class="built_in">free</span>(p);</div><div class="line">        }</div><div class="line">        <span class="comment">// the node has both children</span></div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            s = p-&gt;rchild;</div><div class="line">            <span class="keyword">if</span> (!s-&gt;lchild)</div><div class="line">            s-&gt;lchild = p-&gt;lchild;</div><div class="line">            <span class="keyword">else</span> {  </div><div class="line">            <span class="keyword">while</span> (s-&gt;lchild) {  </div><div class="line">                parent = s;</div><div class="line">                s = s-&gt;lchild;</div><div class="line">            }  </div><div class="line">            parent-&gt;lchild = s-&gt;rchild;</div><div class="line">            s-&gt;lchild = p-&gt;lchild;</div><div class="line">            s-&gt;rchild = p-&gt;rchild;</div><div class="line">            }  </div><div class="line">            *root = s;</div><div class="line">            <span class="built_in">free</span>(p);</div><div class="line">        }  </div><div class="line">    }   </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p-&gt;data) {</div><div class="line">        deleteNode(&(p-&gt;rchild), data);</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; p-&gt;data) {</div><div class="line">        deleteNode(&(p-&gt;lchild), data);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h4 id="查找节点">查找节点</h4>
<p>递归解法：</p>
<ol>
<li>若当前节点为空，返回空节点；</li>
<li>若当前节点的值与要查找的值相同，返回当前节点；</li>
<li>若当前节点的值大于要查找的值，在左子树中继续查找该值；</li>
<li>若当前节点的值小于要查找的值，在右子树中继续查找该值。</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Node* searchNode(Node* &pRoot, <span class="keyword">int</span> x){</div><div class="line">    <span class="keyword">if</span> (pRoot == NULL) <span class="keyword">return</span> NULL;</div><div class="line">    <span class="keyword">if</span> (pRoot-&gt;data == x) <span class="keyword">return</span> pRoot;</div><div class="line">    <span class="keyword">if</span>(x &lt; pRoot-&gt;data)</div><div class="line">        searchNode(pRoot-&gt;lchild, x);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        searchNode(pRoot-&gt;rchild, x);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h2 id="哈希表">哈希表</h2>
<p>下图示意了哈希表（Hash Table）这样的数据结构。</p>
<p><img src="/images/algorithms-data-structure/linkedlist.hashtab.png" alt="哈希表"></p>
<p>如上图所示，首先分配一个指针数组，数组的每个元素是一个链表的头指针，每个链表称为一个 <strong>槽（Slot）</strong> 。哪个数据应该放入哪个槽中由哈希函数决定，在这个例子中我们简单地选取哈希函数h(x) = x % 11，这样任意数据x都可以映射成0~10之间的一个数，就是槽的编号，将数据放入某个槽的操作就是链表的插入操作。</p>
<p>如果每个槽里至多只有一个数据，可以想像这种情况下search、insert和delete操作的时间复杂度都是O(1)，但有时会有多个数据被哈希函数映射到同一个槽中，这称为碰撞（Collision），设计一个好的哈希函数可以把数据比较均匀地分布到各个槽中，<strong>尽量避免碰撞</strong>。如果能把n个数据比较均匀地分布到m个槽中，每个糟里约有n/m个数据，则search、insert和delete和操作的时间复杂度都是O(n/m)，如果n和m的比是常数，则时间复杂度仍然是O(1)。一般来说，要处理的数据越多，构造哈希表时分配的槽也应该越多，所以n和m成正比这个假设是成立的。</p>
<p>如果用我们学过的各种数据结构来表示n个数据的集合，下表是search、insert和delete操作在平均情况下的时间复杂度比较。</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>search</th>
<th>insert</th>
<th>delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>O(n)，有序数组折半查找是O(lgn)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>双向链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>排序二叉树</td>
<td>O(lgn)</td>
<td>O(lgn)</td>
<td>O(lgn)</td>
</tr>
<tr>
<td>哈希表（n与槽数m成正比）</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="典型应用">典型应用</h3>
<ol>
<li><a href="http://blog.csdn.net/shangshanhu/article/details/5917230" target="_blank" rel="external">统计一个文本文件中每个单词的出现次数</a></li>
</ol>
<h2 id="深入阅读">深入阅读</h2>
<ol>
<li><a href="http://blog.csdn.net/luckyxiaoqiang/article/details/7393134" target="_blank" rel="external">轻松搞定面试中的链表题目</a></li>
<li><a href="http://blog.csdn.net/luckyxiaoqiang/article/details/7518888" target="_blank" rel="external">轻松搞定面试中的二叉树题目</a></li>
</ol>


		<!-- pagination -->
		<div>
		<center>
		<div class="pagination">
<ul class="pagination">
	
	
	
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
			
			
			
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	
		<li class="prev"><a data-pjax href="/wiki/algorithms-greedy.html" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
	
	<li><a data-pjax href="/wiki"><i class="fa fa-tasks"></i>Wiki</a></li>
	
		<li class="next"><a data-pjax href="/wiki/algorithm-bit.html" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

	    </center>
		</div>
				
		<!-- toc -->
		
   	<script type="text/javascript">
		jQuery(document).ready(function() {
		
 		   generateWikiTOC('.note', '.toc',  2 , 2 );
		
		});
	</script>



				
		<!-- comment -->
		
<section id="comment">
    <h2 class="title">Comments</h2>
	
	 <div id="comment-thread"></div>
	 <div id="loading-spin"></div>
	 <script type="text/javascript">
	   getComments({
		       type: "github",
	           user: "wzpan",
	           repo: "wzpan.github.io",
			   client_id: "1eb35434de75c06a513f",
			   client_secret: "6e4193f8ecd619cdfac2b1aa16b3663fe18d2e90",
			   no_comment: "暂时还没有留言呢，点击下面的按钮去留言吧！",
			   go_to_comment: "去留言",
			   btn_class: "btn btn-primary",
			   no_issue: "no_issue",
			   issue_title: "数据结构",
			   issue_id: "undefined",
			   comments_target: "#comment-thread" ? "#comment-thread" : "#comment-thread",
			   loading_target: "undefined"
			   });
	 </script>
	
</section>


		

	</div> <!-- span9/span12 -->
</div><!-- row-fluid post-full -->

	</div>	
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2019 Joseph Pan
  
    <small>
     <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"><img title="知识共享许可协议" style="border-width: 0px; vertical-align: middle; display: inline; " src="/images/license.png"></a>
    </small>
</p>
 </footer>
</div> <!-- container-narrow -->


<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/dist/jquery.imagesloaded.min.js"></script>


<script src="/dist/gallery.min.js"></script>
<script src="/dist/bootstrap.min.js"></script>
<script src="/dist/jquery.tableofcontents.min.js"></script>
<script src="/dist/tocgenerator.min.js"></script>
<script src="/dist/require.min.js"></script>
<script src="/dist/main.min.js"></script>



<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox({
    helpers : { 
        title : { type : 'inside' }
    },
    afterLoad : function() {
        this.title = (this.title ? '' + this.title + '<br />' : '') + 'Image ' + (this.index + 1) + ' of ' + this.group.length;
    }
  });
})(jQuery);
</script>




<!-- syntax highlighting -->

  <script>
  marked.setOptions({
    highlight: function (code, lang) {
        return hljs.highlightAuto(code).value;
    }
  });
  function Highlighting(){
    var markdowns = document.getElementsByClassName('markdown');
    for(var i=0;i<markdowns.length;i++){
        if(markdowns[i].innerHTML) markdowns[i].innerHTML =marked(markdowns[i].innerHTML);
    }
  }
  window.addEventListener('DOMContentLoaded', Highlighting, false);
  window.addEventListener('load', Highlighting, false);
  </script>



<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','ney3Rb77vMaWT2KUKFyt');
</script>



<script type="text/x-mathjax-config">
   MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



</body>
</html>
